<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>BSG: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BSG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('todo.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000008"></a>Class <a class="el" href="class_buffered_tag_kmerizer.html">BufferedTagKmerizer</a>  </dt>
<dd>add an option to only use tags with X+ reads.  </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="class_buffered_tag_kmerizer_1_1_stream_kmer_factory.html#a1b9ff6ff94253d9adeca82d1cf5ae0a1">BufferedTagKmerizer::StreamKmerFactory::produce_all_kmers</a>  (const char *seq, std::vector&lt; uint64_t &gt; &amp;mers)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="class_contig_block_factory.html#a4fc9f63494c02a99b1461e618dfd90d7">ContigBlockFactory&lt; FileRecord &gt;::next_elemen2t</a>  (std::vector&lt; Block &gt; &amp;blocks)</dt>
<dd>: this should really be assert(j&gt;=0)  </dd>
<dt><a class="anchor" id="_todo000044"></a>Member <a class="el" href="class_flow_follower.html#a13192e780d6fdb3db600229312560f12">FlowFollower::get_distinctive_kmers_truncated</a>  (std::vector&lt; sgNodeID_t &gt;)</dt>
<dd>: consider the case where both things are completely different!  </dd>
<dt><a class="anchor" id="_todo000045"></a>Member <a class="el" href="class_graph_editor.html#a090aa4c85417aba24d0a2ce7837c4d4a">GraphEditor::detach_path</a>  (<a class="el" href="class_sequence_graph_path.html">SequenceGraphPath</a> p, bool consume_tips=false)</dt>
<dd><p class="startdd">: check the path is valid? </p>
<p>: create a new node with the sequence of the "middle" nodes </p>
<p>: migrate connection from the src node to the first middle node into the new node </p>
<p>: migrate connection from the last middle node to the dest node into the new node </p>
<p class="enddd">: delete nodes from the original path while there is any of them with a disconnecte end.  </p>
</dd>
<dt><a class="anchor" id="_todo000050"></a>Member <a class="el" href="class_graph_editor.html#afa632d7ae5080bf2f57ca34f7ee3aa48">GraphEditor::join_path</a>  (<a class="el" href="class_sequence_graph_path.html">SequenceGraphPath</a> p, bool consume_nodes=false)</dt>
<dd><p class="startdd">:check, this may have a problem with a circle </p>
<p class="enddd">: update read mappings  </p>
</dd>
<dt><a class="anchor" id="_todo000076"></a>Member <a class="el" href="class_graph_node_reader.html#a47453e900f4aae582dd032096a3ad3ac">GraphNodeReader&lt; FileRecord &gt;::GraphNodeReader</a>  (<a class="el" href="struct_graph_node_reader_params.html">GraphNodeReaderParams</a> params)</dt>
<dd>: use this  </dd>
<dt><a class="anchor" id="_todo000032"></a>Member <a class="el" href="class_kmer_compression_index.html#ac90bcaa8e63d5d76cf1f85be31aa876e">KmerCompressionIndex::compute_kci_profiles</a>  (std::string filename)</dt>
<dd><p class="startdd">: complete this to throw a warning when accessing a deleted node </p>
<p class="enddd">: Corregir este threhold  </p>
</dd>
<dt><a class="anchor" id="_todo000031"></a>Member <a class="el" href="class_kmer_compression_index.html#a4dbaecd87153580f1468eab600b02d56">KmerCompressionIndex::index_graph</a>  ()</dt>
<dd>: remove kmers with more than X in count  </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="class_kmer_count_factory.html#a57fd5725eb458f2d8f7adfc29add9cd3">KmerCountFactory&lt; FileRecord &gt;::next_element</a>  (std::vector&lt; KmerCount &gt; &amp;mers)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000016"></a>Member <a class="el" href="classkmer_i_d_x_factory.html#a9e32d8ba40e335a880cd775c2d07ed88">kmerIDXFactory&lt; FileRecord &gt;::next_element</a>  (std::vector&lt; KmerIDX &gt; &amp;mers)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000055"></a>Member <a class="el" href="class_kmer_map_counter.html#a661273ab263bfb42183852f12b93e36a">KmerMapCounter::count_all_kmers</a>  (const char *seq, std::unordered_map&lt; uint64_t, uint32_t &gt; &amp;mers)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000054"></a>Member <a class="el" href="class_kmer_map_creator.html#af0bc0024556f07e8817422aa06611271">KmerMapCreator::create_all_kmers</a>  (const char *seq, std::unordered_map&lt; uint64_t, uint32_t &gt; &amp;mers)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000056"></a>Member <a class="el" href="class_kmer_vector_creator.html#acb4bec191e2675bcfa44e1daa84e0bb8">KmerVectorCreator::count_all_kmers</a>  (const char *seq)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="class_linkage_di_graph.html#aee256f53e023c158ede208b23665bd66">LinkageDiGraph::remove_transitive_links</a>  (int radius)</dt>
<dd>: check mutually transitive connections (A-&gt;B, B-&gt;C, A-&gt;C, C-&gt;B)  </dd>
<dt><a class="anchor" id="_todo000052"></a>Member <a class="el" href="class_linkage_untangler.html#a6f8b0997bc18297248266802c60061cb">LinkageUntangler::expand_linear_regions</a>  (const <a class="el" href="class_linkage_di_graph.html">LinkageDiGraph</a> &amp;)</dt>
<dd><p class="startdd">: now use tags and LMPs to find paths between elements in the line"&lt;&lt;std::endl; &lt;p&gt;: maybe ask for more than 1 read coverage? &lt;/dd&gt; &lt;dt&gt;\anchor _todo000034
Member \_internalref class_linked_read_mapper#a9b3cec145f07f6f7c739713bc6a91987 "<a class="el" href="class_linked_read_mapper.html#a9b3cec145f07f6f7c739713bc6a91987">LinkedReadMapper::map_reads</a>" (std::unordered_set&lt; uint64_t &gt; const &amp;reads_to_remap={})&lt;/dt&gt;&lt;dd&gt; : sort out the sign/orientation representation &lt;p&gt;: allow mapping to consecutive nodes &lt;/dd&gt; &lt;dt&gt;\anchor _todo000036
Member \_internalref class_linked_read_mapper#ad40ebc9c92b9e278bf9cb5786d1cc5dc "<a class="el" href="class_linked_read_mapper.html#ad40ebc9c92b9e278bf9cb5786d1cc5dc" title="Mapping of paired end read files. ">LinkedReadMapper::remove_obsolete_mappings</a>" () fix and test 10x tags processing </p>
<p>enable some basic 10x tag statistics </p>
<p>add support for LMP reads (i.e FR reads) </p>
<p>add distribution computing on the fly </p>
<p class="enddd">support other kind of indexes and variable k-mer size  </p>
</dd>
<dt><a class="anchor" id="_todo000037"></a>Member <a class="el" href="class_linked_read_mapper_1_1_stream_kmer_factory.html#a886e9bff9a5f530787a0248b5a5c403c">LinkedReadMapper::StreamKmerFactory::produce_all_kmers</a>  (const char *seq, std::vector&lt; KmerIDX &gt; &amp;mers)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000006"></a>Member <a class="el" href="class_linked_reads_datastore.html#a88bc25f6a962fa438c7777ed409113d4">LinkedReadsDatastore::build_from_fastq</a>  (std::string read1_filename, std::string read2_filename, std::string output_filename, LinkedReadsFormat format, int readsize=250, size_t chunksize=10000000)</dt>
<dd>: save space first for the tag index!!!  </dd>
<dt><a class="anchor" id="_todo000007"></a>Member <a class="el" href="class_linked_reads_datastore.html#a996948ab56ee59b7b41913cd6df19e5a">LinkedReadsDatastore::get_tags_kmers</a>  (int k, int min_tag_cov, std::set&lt; bsg10xTag &gt; tags, <a class="el" href="class_buffered_l_r_sequence_getter.html">BufferedLRSequenceGetter</a> &amp;blrsg)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000043"></a>Member <a class="el" href="class_node_mapper.html#aae45390d639889ab316d243aa0e0a6ce">NodeMapper::map_kmers_to_graph</a>  (seqID_t id, std::vector&lt; KmerIDX &gt; &amp;kmers)</dt>
<dd>: Check if this last push_back is required  </dd>
<dt><a class="anchor" id="_todo000068"></a>Member <a class="el" href="class_paired_read_linker.html#a2d79e91c52a2fc7bc0d2de0a7748eb9e">PairedReadLinker::generate_links</a>  (const std::vector&lt; bool &gt; &amp;to_link, int min_reads=5)</dt>
<dd><p class="startdd">: remove printing </p>
<p class="enddd">:hardcoded LMP orientation  </p>
</dd>
<dt><a class="anchor" id="_todo000070"></a>Member <a class="el" href="class_paired_read_linker.html#a882fb2b8454f2a6d63c65e9874126e45">PairedReadLinker::remove_transitive_links</a>  (int radius)</dt>
<dd>: check mutually transitive connections (A-&gt;B, B-&gt;C, A-&gt;C, C-&gt;B)  </dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="class_paired_read_mapper.html#a4ded1995b819be69abe05869ad24feb3">PairedReadMapper::map_reads</a>  (std::unordered_set&lt; uint64_t &gt; const &amp;reads_to_remap={})</dt>
<dd><p class="startdd">: sort out the sign/orientation representation </p>
<p>:break mapping by change of direction and such </p>
<p class="enddd">: allow mapping to consecutive nodes  </p>
</dd>
<dt><a class="anchor" id="_todo000042"></a>Member <a class="el" href="class_paired_read_mapper.html#a92bd5f40a04cdc887dd5d62e07ecf986">PairedReadMapper::read_direction_in_node</a>  </dt>
<dd>: reading and writing this would simplify things??  </dd>
<dt><a class="anchor" id="_todo000041"></a>Member <a class="el" href="class_paired_read_mapper.html#a3ee881164f07f6fe9752b3664eda71a3">PairedReadMapper::remove_obsolete_mappings</a>  ()</dt>
<dd><p class="startdd">fix and test 10x tags processing </p>
<p>enable some basic 10x tag statistics </p>
<p>add support for LMP reads (i.e FR reads) </p>
<p>add distribution computing on the fly </p>
<p class="enddd">support other kind of indexes and variable k-mer size  </p>
</dd>
<dt><a class="anchor" id="_todo000011"></a>Member <a class="el" href="class_paired_reads_datastore.html#a3f83ac32496874c346773d0bb09c8586">PairedReadsDatastore::_size</a>  </dt>
<dd>: save size  </dd>
<dt><a class="anchor" id="_todo000080"></a>Member <a class="el" href="class_scaffolder.html#ac65d815ee9da4c8386fd043638a78058">Scaffolder::all_read_links</a>  (sgNodeID_t source, unsigned lib)</dt>
<dd>:check this, configure library direction  </dd>
<dt><a class="anchor" id="_todo000078"></a>Member <a class="el" href="class_scaffolder.html#a3ec9f642ce59e6714c856202e33a6170">Scaffolder::find_canonical_repeats</a>  ()</dt>
<dd>: Adapt for repeat resolution.  </dd>
<dt><a class="anchor" id="_todo000079"></a>Member <a class="el" href="class_scaffolder.html#aefedcd5c8ffd0b8c7c4851153e7fda57">Scaffolder::get_all_haplotype_pairs</a>  (uint32_t maxpairs=0)</dt>
<dd>: check the coverages are actually correct?  </dd>
<dt><a class="anchor" id="_todo000077"></a>Member <a class="el" href="class_scaffolder.html#a761699ce19d3d9c02aab2efcd8a76ee1">Scaffolder::pop_unsupported_shortbubbles</a>  (uint64_t max_length=450)</dt>
<dd>: de-hardcode the 20% coverage rule  </dd>
<dt><a class="anchor" id="_todo000023"></a>Member <a class="el" href="class_sequence_graph.html#a2b97fefb249fa31cf4847b7050075d13">SequenceGraph::connected_components</a>  (int max_nr_totalinks=0, int max_nr_dirlinks=0, int min_rsize=0)</dt>
<dd>: first find all repeats, add them as independent components and mark them as used.  </dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="class_sequence_graph.html#a84b8d6ab28c22c20a468b1743796d4b0">SequenceGraph::create_index</a>  ()</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="class_sequence_graph.html#a63599718b3a685c020739c2150bc3595">SequenceGraph::expand_node</a>  (sgNodeID_t nodeID, std::vector&lt; std::vector&lt; sgNodeID_t &gt;&gt; bw, std::vector&lt; std::vector&lt; sgNodeID_t &gt;&gt; fw)</dt>
<dd>: check all inputs are included in bw and all outputs are included in fw, only once  </dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="class_sequence_graph.html#aa1b3d73ea21068c1ec2a754363ebb400">SequenceGraph::find_bubbles</a>  (std::vector&lt; sgNodeID_t &gt;)</dt>
<dd>: &ndash;&gt; enable extra breaks in repeats  </dd>
<dt><a class="anchor" id="_todo000025"></a>Member <a class="el" href="class_sequence_graph.html#ad7f54e2a8e0a2e74ee21af581ce82c84">SequenceGraph::join_path</a>  (const <a class="el" href="class_sequence_graph_path.html">SequenceGraphPath</a> p, bool consume_nodes=true)</dt>
<dd><p class="startdd">:check, this may have a problem with a circle </p>
<p class="enddd">: update read mappings  </p>
</dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="class_sequence_graph.html#a4945ecec40b1cc7c692bcbaf31b60906">SequenceGraph::link_exists</a>  (sgNodeID_t from, sgNodeID_t to) const </dt>
<dd>: Can this just be a std::find?  </dd>
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="class_sequence_graph.html#ad74b30a2e01c0c84ce5c52048cf2d3d0">SequenceGraph::load_from_gfa</a>  (std::string filename)</dt>
<dd>: better checks for M  </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="class_sequence_graph.html#a524c7fb72c64c1eb7c25a1cb73114193">SequenceGraph::remove_node</a>  (sgNodeID_t n)</dt>
<dd><p class="startdd">: this is a lazy solution </p>
<p class="enddd">: remove read mappings  </p>
</dd>
<dt><a class="anchor" id="_todo000005"></a>Class <a class="el" href="classsglib_1_1alignment_1_1scoring_1_1_substitution_matrix.html">sglib::alignment::scoring::SubstitutionMatrix&lt; T &gt;</a>  </dt>
<dd>: Make substitution matrix work for AA sequences in future too, not just DNA.  </dd>
<dt><a class="anchor" id="_todo000018"></a>Member <a class="el" href="class_skip_mer_i_d_x_factory.html#aad94023f1f1c4ecdfba5725001c5e2fe">SkipMerIDXFactory&lt; FileRecord &gt;::next_element</a>  (std::vector&lt; MinPosIDX &gt; &amp;mers)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="class_stranded_minimiser_sketch_factory.html#aafa768ec4ce8545cc956d271d72b8fc0">StrandedMinimiserSketchFactory::getMinSketch</a>  (const std::string &amp;seq, std::vector&lt; MinPosIDX &gt; &amp;sketch)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="class_stream_kmer_factory.html#a5a4e7a3c483a2341dfe4dc6a5b3c3236">StreamKmerFactory::produce_all_kmers</a>  (const int64_t seqID, const char *seq, std::vector&lt; KmerIDX &gt; &amp;mers)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="class_string_k_mer_factory.html#aff34d2ccaa9d9ddda612f760cb470979">StringKMerFactory::create_kmers</a>  (std::vector&lt; uint64_t &gt; &amp;mers)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000057"></a>Member <a class="el" href="class_uncovered_kmer_counter.html#a351ac37435627c9b9358aaf4a532bf59">UncoveredKmerCounter::count_uncovered</a>  (const char *seq)</dt>
<dd>: Adjust for when K is larger than what fits in uint64_t!  </dd>
<dt><a class="anchor" id="_todo000072"></a>Member <a class="el" href="class_untangler.html#a4a0342058888dad2d987251ddef5d108">Untangler::analise_paths_through_nodes</a>  ()</dt>
<dd>: deprecate  </dd>
<dt><a class="anchor" id="_todo000075"></a>Member <a class="el" href="class_untangler.html#a2ab55e3bd04984f756af0f77cc9ac2c3">Untangler::connect_neighbours</a>  (uint64_t min_size, float min_ci, float max_ci, int64_t max_distance)</dt>
<dd><p class="startdd">: just deprecate these ASAP </p>
<p class="enddd">: only fw or bw neighbour, corresponding, good tag intersection  </p>
</dd>
<dt><a class="anchor" id="_todo000066"></a>Member <a class="el" href="class_untangler.html#a9d2be737b7d2e7842492785b9abb453a">Untangler::connect_neighbours_paths_to_same</a>  (uint64_t min_size, float min_ci, float max_ci, int64_t max_distance, const std::vector&lt; std::vector&lt; std::pair&lt; sgNodeID_t, uint32_t &gt;&gt;&gt; &amp;tagneighbours, const std::vector&lt; std::vector&lt; std::pair&lt; sgNodeID_t, int64_t &gt;&gt;&gt; &amp;bndist, const std::vector&lt; std::vector&lt; std::pair&lt; sgNodeID_t, int64_t &gt;&gt;&gt; &amp;fndist)</dt>
<dd>: this can be doen not with a factory but with a class that already counts how many are in the set  </dd>
<dt><a class="anchor" id="_todo000071"></a>Member <a class="el" href="class_untangler.html#ab78f66fdc696db46f18a0418c6749658">Untangler::extend_HSPNPs_by_tagwalking</a>  ()</dt>
<dd>: deprecate  </dd>
<dt><a class="anchor" id="_todo000064"></a>Member <a class="el" href="class_untangler.html#a23b9f64ad4194c8740333ab7891c043c">Untangler::find_tag_neighbours_with_imbalance</a>  (uint32_t min_size, float min_ci, float max_ci, float end_perc=.1)</dt>
<dd>: divide this and make iterative: start by big fish, then add small in-betweens, simplify transitives into subgraphs  </dd>
<dt><a class="anchor" id="_todo000073"></a>Member <a class="el" href="class_untangler.html#a1f1c5db1f0e2d5f1aacdc040328570d2">Untangler::get_all_HSPNPs</a>  ()</dt>
<dd><p class="startdd">: deprecate </p>
<p>: move to <a class="el" href="class_sequence_graph.html" title="Class representing sequence graphs. ">SequenceGraph</a> </p>
<p class="enddd">: check the coverages are actually correct?  </p>
</dd>
<dt><a class="anchor" id="_todo000067"></a>Member <a class="el" href="class_untangler.html#af5d8511828f1d9f6c494253df8c67c9b">Untangler::get_all_tag_covered_paths</a>  (sgNodeID_t from, sgNodeID_t to, std::set&lt; bsg10xTag &gt; &amp;tags, <a class="el" href="class_buffered_tag_kmerizer.html" title="kmerises sets of tags, but saves the kmers of individual tags in a buffer to speed-up going through m...">BufferedTagKmerizer</a> &amp;btk)</dt>
<dd>: this can be doen not with a factory but with a class that already counts how many are in the set  </dd>
<dt><a class="anchor" id="_todo000059"></a>Member <a class="el" href="class_untangler.html#a89273e74b00b26fc5d18c26340fc1225">Untangler::solve_bubbly_path_2</a>  (const <a class="el" href="class_sequence_sub_graph.html">SequenceSubGraph</a> &amp;bp)</dt>
<dd><p class="startdd">:prioritise clean start (shared=0) </p>
<p>: discount already-shared tags from penalty; </p>
<p class="enddd">support partial solutions! (i.e. re-run with broken bubbly path?)  </p>
</dd>
<dt><a class="anchor" id="_todo000062"></a>Member <a class="el" href="class_untangler.html#ae2506fd72b64a11eb91413ef29054a3d">Untangler::solve_bubbly_paths</a>  ()</dt>
<dd><p class="startdd">: 3-part structure: </p>
<p class="enddd">: write a more sophisticated kci check </p>
</dd>
</dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
