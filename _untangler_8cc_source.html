<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>BSG: /home/travis/build/ljyanesm/sg/src/sglib/processors/Untangler.cc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BSG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_untangler_8cc_source.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Untangler.cc</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">// Created by Bernardo Clavijo (EI) on 26/02/2018.</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="preprocessor">#include &lt;sglib/graph/SequenceGraphPath.hpp&gt;</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#include &quot;Untangler.hpp&quot;</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#include &quot;TagWalker.hpp&quot;</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">struct </span><a class="code" href="struct_counter.html">Counter</a></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;{</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    <span class="keyword">struct </span>value_type { <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; value_type(<span class="keyword">const</span> T&amp;) { } };</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <span class="keywordtype">void</span> push_back(<span class="keyword">const</span> value_type&amp;) { ++count; }</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <span class="keywordtype">size_t</span> count = 0;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;};</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="keywordtype">size_t</span> intersection_size(<span class="keyword">const</span> T1&amp; s1, <span class="keyword">const</span> T2&amp; s2)</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;{</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <a class="code" href="struct_counter.html">Counter</a> c;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), std::back_inserter(c));</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="keywordflow">return</span> c.count;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;}</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;uint64_t Untangler::solve_canonical_repeats_by_tags(std::unordered_set&lt;uint64_t&gt; &amp;reads_to_remap) {</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    std::unordered_set&lt;sgNodeID_t&gt; unsolved_repeats;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    unsolved_repeats.clear();</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    uint64_t aa_count=0,ab_count=0,unsolved_count=0,non_evaluated=0;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot; Finding trivial repeats to analyse with tags&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    std::vector&lt;bool&gt; used(ws.getGraph().nodes.size());</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    std::vector&lt;SequenceGraphPath&gt; paths_solved;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="comment">//if (ws.verbose_log!=&quot;&quot;) verbose_log_file&lt;&lt;&quot;==== Round of repetition analysis started ====&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n = 1; n &lt; ws.getGraph().nodes.size(); ++n) {</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="keywordflow">if</span> (used[n]) {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;            <span class="comment">//if (verbose_log!=&quot;&quot;) verbose_log_file&lt;&lt;n&lt;&lt;&quot; is used&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        }</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="keyword">auto</span> fwl = ws.getGraph().<a class="code" href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">get_fw_links</a>(n);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keyword">auto</span> bwl = ws.getGraph().<a class="code" href="class_sequence_graph.html#a8429832b3d8f54b51dc42e444f7e6191">get_bw_links</a>(n);</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="keywordflow">if</span> (fwl.size() != 2 or bwl.size() != 2) {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            <span class="comment">//if (verbose_log!=&quot;&quot;) verbose_log_file&lt;&lt;n&lt;&lt;&quot; has &quot;&lt;&lt;bwl.size()&lt;&lt;&quot; ins and &quot;&lt;&lt;fwl.size()&lt;&lt;&quot; outs&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <span class="keyword">auto</span> f0 = fwl[0].dest;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <span class="keyword">auto</span> f1 = fwl[1].dest;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keyword">auto</span> b0 = bwl[0].dest;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="keyword">auto</span> b1 = bwl[1].dest;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="keywordflow">if</span> (used[(b0 &gt; 0 ? b0 : -b0)] or used[(b1 &gt; 0 ? b1 : -b1)] or used[(f0 &gt; 0 ? f0 : -f0)] or</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;            used[(f1 &gt; 0 ? f1 : -f1)]) {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;            non_evaluated++;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            <span class="comment">//if (verbose_log!=&quot;&quot;) verbose_log_file&lt;&lt;n&lt;&lt;&quot; neighbors are used&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        }</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        sgNodeID_t all[4] = {f0, f1, b0, b1};</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordtype">bool</span> ok = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> x:all) <span class="keywordflow">if</span> (x == n or x == -n or ws.getGraph().nodes[(x &gt; 0 ? x : -x)].sequence.size() &lt; 199) ok = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> j = 0; j &lt; 3; ++j)</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = j + 1; i &lt; 4; ++i)</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                <span class="keywordflow">if</span> (all[i] == all[j] or all[i] == -all[j])ok = <span class="keyword">false</span>; <span class="comment">//looping node</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <span class="keywordflow">if</span> (!ok) {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            <span class="comment">//if (verbose_log!=&quot;&quot;) verbose_log_file&lt;&lt;n&lt;&lt;&quot; and neighbors are short&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        }</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">//                std::cout&lt;&lt;&quot;Repeat: [ &quot;&lt;&lt;-b0&lt;&lt;&quot; | &quot;&lt;&lt;-b1&lt;&lt;&quot; ] &lt;-&gt; &quot;&lt;&lt;n&lt;&lt;&quot; &lt;-&gt; [ &quot;&lt;&lt;f0&lt;&lt;&quot; | &quot;&lt;&lt;f1&lt;&lt;&quot; ]&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        std::set&lt;bsg10xTag&gt; b0tags, b1tags, f0tags, f1tags;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment">//                std::cout&lt;&lt;&quot;Reads in nodes -&gt; f0:&quot;&lt;&lt;scaff.lrmappers[0].reads_in_node[(f0 &gt; 0 ? f0 : -f0)].size()</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment">//                        &lt;&lt;&quot;   f1:&quot;&lt;&lt;scaff.lrmappers[0].reads_in_node[(f1 &gt; 0 ? f1 : -f1)].size()</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment">//                        &lt;&lt;&quot;   b0:&quot;&lt;&lt;scaff.lrmappers[0].reads_in_node[(b0 &gt; 0 ? b0 : -b0)].size()</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">//                        &lt;&lt;&quot;   b1:&quot;&lt;&lt;scaff.lrmappers[0].reads_in_node[(b1 &gt; 0 ? b1 : -b1)].size()&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> rm:ws.getLinkedReadMappers()[0].reads_in_node[(f0 &gt; 0 ? f0 : -f0)])</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            f0tags.insert(ws.getLinkedReadMappers()[0].datastore.get_read_tag(rm.read_id));</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> rm:ws.getLinkedReadMappers()[0].reads_in_node[(f1 &gt; 0 ? f1 : -f1)])</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            f1tags.insert(ws.getLinkedReadMappers()[0].datastore.get_read_tag(rm.read_id));</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> rm:ws.getLinkedReadMappers()[0].reads_in_node[(b0 &gt; 0 ? b0 : -b0)])</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            b0tags.insert(ws.getLinkedReadMappers()[0].datastore.get_read_tag(rm.read_id));</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> rm:ws.getLinkedReadMappers()[0].reads_in_node[(b1 &gt; 0 ? b1 : -b1)])</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            b1tags.insert(ws.getLinkedReadMappers()[0].datastore.get_read_tag(rm.read_id));</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        f0tags.erase(0);</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        f1tags.erase(0);</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        b0tags.erase(0);</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        b1tags.erase(0);</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        std::set&lt;bsg10xTag&gt; shared1,shared2;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:f0tags) <span class="keywordflow">if</span> (f1tags.count(t)&gt;0) {shared1.insert(t);};</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:shared1){f0tags.erase(t);f1tags.erase(t);};</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:b0tags) <span class="keywordflow">if</span> (b1tags.count(t)&gt;0) {shared2.insert(t);};</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:shared2) {b0tags.erase(t);b1tags.erase(t);};</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        std::set&lt;bsg10xTag&gt; aa, bb, ba, ab;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        std::set_intersection(b0tags.begin(), b0tags.end(), f0tags.begin(), f0tags.end(),</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                              std::inserter(aa, aa.end()));</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        std::set_intersection(b0tags.begin(), b0tags.end(), f1tags.begin(), f1tags.end(),</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                              std::inserter(ab, ab.end()));</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        std::set_intersection(b1tags.begin(), b1tags.end(), f0tags.begin(), f0tags.end(),</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                              std::inserter(ba, ba.end()));</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        std::set_intersection(b1tags.begin(), b1tags.end(), f1tags.begin(), f1tags.end(),</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                              std::inserter(bb, bb.end()));</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment">//                std::cout&lt;&lt;&quot;Tags in   f0: &quot;&lt;&lt;f0tags.size()&lt;&lt;&quot;  f1: &quot;&lt;&lt;f1tags.size()&lt;&lt;&quot;  b0: &quot;&lt;&lt;b0tags.size()&lt;&lt;&quot;  b1: &quot;&lt;&lt;b1tags.size()&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment">//                std::cout&lt;&lt;&quot;Tags support   aa: &quot;&lt;&lt;aa.size()&lt;&lt;&quot;  bb: &quot;&lt;&lt;bb.size()&lt;&lt;&quot;  ab: &quot;&lt;&lt;ab.size()&lt;&lt;&quot;  ba: &quot;&lt;&lt;ba.size();</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="keywordflow">if</span> (aa.size() &gt; 3 and bb.size() &gt; 3 and</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            std::min(aa.size(), bb.size()) &gt; 10 * std::max(ab.size(), ba.size())) {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;            <span class="comment">//std::cout &lt;&lt; &quot; Solved as AA BB !!!&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            used[(b0 &gt; 0 ? b0 : -b0)] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            used[(b1 &gt; 0 ? b1 : -b1)] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            used[n] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            used[(f0 &gt; 0 ? f0 : -f0)] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            used[(f1 &gt; 0 ? f1 : -f1)] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            paths_solved.push_back(<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(ws.getGraph(), {-b0, n, f0}));</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;            paths_solved.push_back(<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(ws.getGraph(), {-b1, n, f1}));</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            ++aa_count;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ba.size() &gt; 3 and ab.size() &gt; 3 and</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                   std::min(ba.size(), ab.size()) &gt; 10 * std::max(aa.size(), bb.size())) {</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            <span class="comment">//std::cout &lt;&lt; &quot; Solved as AB BA !!!&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            used[(b0 &gt; 0 ? b0 : -b0)] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            used[(b1 &gt; 0 ? b1 : -b1)] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;            used[n] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            used[(f0 &gt; 0 ? f0 : -f0)] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;            used[(f1 &gt; 0 ? f1 : -f1)] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            paths_solved.push_back(<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(ws.getGraph(), {-b0, n, f1}));</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            paths_solved.push_back(<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(ws.getGraph(), {-b1, n, f0}));</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            ++ab_count;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        }</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            unsolved_repeats.insert(n);</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            ++unsolved_count;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            <span class="comment">//if (verbose_log!=&quot;&quot;) verbose_log_file&lt;&lt;n&lt;&lt;&quot; unsolved aa: &quot;&lt;&lt;aa.size()&lt;&lt;&quot;  bb: &quot;&lt;&lt;bb.size()&lt;&lt;&quot;  ab: &quot;&lt;&lt;ab.size()&lt;&lt;&quot;  ba: &quot;&lt;&lt;ba.size()&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        }</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    }</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    std::cout &lt;&lt; paths_solved.size() &lt;&lt; <span class="stringliteral">&quot; paths to join&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="comment">//if (paths_solved.size() &gt; 0) mod = true;</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    reads_to_remap;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p:paths_solved) {</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        ws.getGraph().<a class="code" href="class_sequence_graph.html#ad7f54e2a8e0a2e74ee21af581ce82c84">join_path</a>(p);</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:p.getNodes()) {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> rm:ws.getLinkedReadMappers()[0].reads_in_node[(n &gt; 0 ? n : -n)]) {</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                reads_to_remap.insert((rm.read_id % 2 ? rm.read_id : rm.read_id - 1));</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                ws.getLinkedReadMappers()[0].read_to_node[rm.read_id] = 0;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            }</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        }</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    }</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;Path analysis summary AA:&quot;</span>&lt;&lt;aa_count&lt;&lt;<span class="stringliteral">&quot; AB:&quot;</span>&lt;&lt;ab_count</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;             &lt;&lt;<span class="stringliteral">&quot; Unsolved:&quot;</span>&lt;&lt;unsolved_count&lt;&lt;<span class="stringliteral">&quot; Non evaluated:&quot;</span>&lt;&lt;non_evaluated&lt;&lt;std::endl;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    <span class="keywordflow">return</span> paths_solved.size();</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;}</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;uint64_t Untangler::expand_canonical_repeats_by_tags(<span class="keywordtype">float</span> min_ci, <span class="keywordtype">float</span> max_ci, <span class="keywordtype">int</span> min_tags) {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    uint64_t aa_count=0,ab_count=0,unsolved_count=0;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keyword">auto</span> linked_read_mappers = ws.getLinkedReadMappers();</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="keyword">auto</span> kci = ws.getKCI();</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot; Finding trivial repeats to analyse with tags&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n = 1; n &lt; ws.getGraph().nodes.size(); ++n) {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keyword">auto</span> fwl = ws.getGraph().<a class="code" href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">get_fw_links</a>(n);</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="keyword">auto</span> bwl = ws.getGraph().<a class="code" href="class_sequence_graph.html#a8429832b3d8f54b51dc42e444f7e6191">get_bw_links</a>(n);</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        <span class="keywordflow">if</span> (fwl.size() != 2 or bwl.size() != 2) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keyword">auto</span> f0 = fwl[0].dest;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="keyword">auto</span> f1 = fwl[1].dest;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keyword">auto</span> b0 = bwl[0].dest;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keyword">auto</span> b1 = bwl[1].dest;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keywordflow">if</span> (ws.getGraph().<a class="code" href="class_sequence_graph.html#a8429832b3d8f54b51dc42e444f7e6191">get_bw_links</a>(f0).size()!=1</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;            or ws.getGraph().<a class="code" href="class_sequence_graph.html#a8429832b3d8f54b51dc42e444f7e6191">get_bw_links</a>(f1).size()!=1</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;               or ws.getGraph().<a class="code" href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">get_fw_links</a>(b0).size()!=1</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                  or ws.getGraph().<a class="code" href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">get_fw_links</a>(b1).size()!=1)</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        sgNodeID_t all[4] = {f0, f1, b0, b1};</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        <span class="keywordtype">bool</span> ok = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> x:all) <span class="keywordflow">if</span> (x == n or x == -n or ws.getGraph().nodes[(x &gt; 0 ? x : -x)].sequence.size() &lt; 199) ok = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> j = 0; j &lt; 3; ++j)</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = j + 1; i &lt; 4; ++i)</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                <span class="keywordflow">if</span> (all[i] == all[j] or all[i] == -all[j])ok = <span class="keyword">false</span>; <span class="comment">//looping node</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        <span class="keywordflow">if</span> (!ok) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keyword">auto</span> f0t=linked_read_mappers[0].get_node_tags(f0); <span class="keywordflow">if</span> (f0t.size()&lt;min_tags) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        <span class="keyword">auto</span> f1t=linked_read_mappers[0].get_node_tags(f1); <span class="keywordflow">if</span> (f1t.size()&lt;min_tags) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <span class="keyword">auto</span> b0t=linked_read_mappers[0].get_node_tags(b0); <span class="keywordflow">if</span> (b0t.size()&lt;min_tags) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        <span class="keyword">auto</span> b1t=linked_read_mappers[0].get_node_tags(b1); <span class="keywordflow">if</span> (b1t.size()&lt;min_tags) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keyword">auto</span> cif0=kci.compute_compression_for_node(f0,1);</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="keywordflow">if</span> (cif0&lt;min_ci or cif0&gt;max_ci) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        <span class="keyword">auto</span> cif1=kci.compute_compression_for_node(f1,1);</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        <span class="keywordflow">if</span> (cif1&lt;min_ci or cif1&gt;max_ci) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        <span class="keyword">auto</span> cib0=kci.compute_compression_for_node(b0,1);</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="keywordflow">if</span> (cib0&lt;min_ci or cib0&gt;max_ci) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        <span class="keyword">auto</span> cib1=kci.compute_compression_for_node(b1,1);</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="keywordflow">if</span> (cib1&lt;min_ci or cib1&gt;max_ci) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        uint64_t aa=intersection_size(b0t,f0t);</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        uint64_t bb=intersection_size(b1t,f1t);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        uint64_t ab=intersection_size(b0t,f1t);</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        uint64_t ba=intersection_size(b1t,f0t);</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">if</span> (aa &gt; min_tags and bb &gt; min_tags and std::min(aa, bb) &gt; 10 * std::max(ab, ba)) {</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            ++aa_count;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            ws.getGraph().<a class="code" href="class_sequence_graph.html#a63599718b3a685c020739c2150bc3595">expand_node</a>(n,{{b0},{b1}},{{f0},{f1}});</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ba &gt; min_tags and ab &gt; min_tags and std::min(ba, ab) &gt; 10 * std::max(aa, bb)) {</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            ++ab_count;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            ws.getGraph().<a class="code" href="class_sequence_graph.html#a63599718b3a685c020739c2150bc3595">expand_node</a>(n,{{b0},{b1}},{{f1},{f0}});</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        }</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;            ++unsolved_count;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        }</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    }</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;Repeat expansion summary AA:&quot;</span>&lt;&lt;aa_count&lt;&lt;<span class="stringliteral">&quot; AB:&quot;</span>&lt;&lt;ab_count &lt;&lt;<span class="stringliteral">&quot; Unsolved:&quot;</span>&lt;&lt;unsolved_count&lt;&lt;std::endl;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="keywordflow">return</span> aa_count+ab_count;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;}</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div>
<div class="line"><a name="l00214"></a><span class="lineno"><a class="line" href="class_untangler.html#a1f1c5db1f0e2d5f1aacdc040328570d2">  214</a></span>&#160;std::vector&lt;std::pair&lt;sgNodeID_t,sgNodeID_t&gt;&gt; <a class="code" href="class_untangler.html#a1f1c5db1f0e2d5f1aacdc040328570d2">Untangler::get_all_HSPNPs</a>() {</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <span class="keyword">auto</span> kci = ws.getKCI();</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    std::vector&lt;std::pair&lt;sgNodeID_t,sgNodeID_t&gt;&gt; hps;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    std::vector&lt;bool&gt; used(ws.getGraph().nodes.size(),<span class="keyword">false</span>);</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="comment">//TODO: check the coverages are actually correct?</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">double</span> min_c1=0.5,max_c1=1.5,min_c2=1.25,max_c2=3;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="comment">/*</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">     * the loop always keep the first and the last elements as c=2 collapsed nodes.</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment">     * it starts with a c=2 node, and goes thorugh all bubbles fw, then reverts the subgraph and repeats</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="preprocessor">#pragma omp parallel for schedule(static, 10)</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="preprocessor"></span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n=1;n&lt;ws.getGraph().nodes.size();++n){</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        std::pair&lt;sgNodeID_t,sgNodeID_t&gt; hap={0,0};</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="keywordflow">if</span> (ws.getGraph().nodes[n].status==sgNodeDeleted) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="comment">//auto frontkci=kci.compute_compression_for_node(n);</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <span class="comment">//if (frontkci&gt;max_c2 or frontkci&lt;min_c2) continue;</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <span class="keyword">auto</span> m=n;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <span class="comment">//two passes: 0-&gt;fw, 1-&gt;bw,</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> pass=0; pass&lt;2; ++pass,m=-m) {</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            <span class="comment">//check bubble going forward ------------</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            <span class="keyword">auto</span> fw_l = ws.getGraph().<a class="code" href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">get_fw_links</a>(m);</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;            <span class="comment">//fork opening</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            <span class="keywordflow">if</span> (fw_l.size() != 2) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;            hap.first = fw_l[0].dest;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;            hap.second = fw_l[1].dest;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            <span class="keywordtype">bool</span> used_hspnp;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="preprocessor">            #pragma omp critical(find_hspnp_used)</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="preprocessor"></span>            {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                used_hspnp = (used[(hap.first &gt; 0 ? hap.first : -hap.first)] or</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                              used[(hap.second &gt; 0 ? hap.second : -hap.second)]);</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                <span class="keywordflow">if</span> (!used_hspnp){</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                    used[(hap.first&gt;0?hap.first:-hap.first)]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                    used[(hap.second&gt;0?hap.second:-hap.second)]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                }</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            }</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;            <span class="keywordflow">if</span> (used_hspnp) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            <span class="keywordflow">if</span> (hap.first == n or hap.first == -n or hap.second == n or hap.second == -n or hap.first == hap.second) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            <span class="comment">//fork.closing</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            <span class="keyword">auto</span> hap0f = ws.getGraph().<a class="code" href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">get_fw_links</a>(hap.first);</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            <span class="keyword">auto</span> hap1f = ws.getGraph().<a class="code" href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">get_fw_links</a>(hap.second);</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            <span class="keywordflow">if</span> (hap0f.size() != 1 or hap1f.size() != 1 or hap0f[0].dest != hap1f[0].dest) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            <span class="keyword">auto</span> h0kc = kci.compute_compression_for_node(hap.first);</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="keywordflow">if</span> (h0kc &gt; max_c1 or h0kc &lt; min_c1) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            <span class="keyword">auto</span> h1kc = kci.compute_compression_for_node(hap.second);</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            <span class="keywordflow">if</span> (h1kc &gt; max_c1 or h1kc &lt; min_c1) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            <span class="comment">//auto ekc = kci.compute_compression_for_node(hap0f[0].dest);</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            <span class="comment">//if (ekc &gt; max_c2 or ekc &lt; min_c2) continue;</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="preprocessor">#pragma omp critical(hps)</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="preprocessor"></span>            {</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                hps.push_back(hap);</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                <span class="keywordflow">if</span> (hps.size()%1000==0) sglib::OutputLog()&lt;&lt;hps.size()&lt;&lt;<span class="stringliteral">&quot; haplotype pairs found&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            }</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    }</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    sglib::OutputLog()&lt;&lt;hps.size()&lt;&lt;<span class="stringliteral">&quot; haplotype pairs found (DONE)&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keywordflow">return</span> hps;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;}</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div>
<div class="line"><a name="l00280"></a><span class="lineno"><a class="line" href="class_untangler.html#ab78f66fdc696db46f18a0418c6749658">  280</a></span>&#160;uint64_t <a class="code" href="class_untangler.html#ab78f66fdc696db46f18a0418c6749658">Untangler::extend_HSPNPs_by_tagwalking</a>() {</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> hps=<a class="code" href="class_untangler.html#a1f1c5db1f0e2d5f1aacdc040328570d2">get_all_HSPNPs</a>();</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <span class="comment">//std::cout&lt;&lt;&quot;limiting HSPNs to 1000!!! (for test purposes)&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="comment">//hps.resize(100);</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    std::atomic&lt;uint64_t&gt; processing(0);</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    std::vector&lt;std::vector&lt;SequenceGraphPath&gt;&gt; new_ppaths;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="preprocessor">#pragma omp parallel for</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="preprocessor"></span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=0;i&lt;hps.size();++i) {</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        uint64_t p;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="keywordflow">if</span> ((p=++processing)%100==0) sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;Procesing HSPNP #&quot;</span>&lt;&lt;p&lt;&lt;std::endl;</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="comment">//if (ws.sg.nodes[llabs(hp.first)].sequence.size()&lt;2000 or ws.sg.nodes[llabs(hp.second)].sequence.size()&lt;2000 ) continue;</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <a class="code" href="class_tag_walker.html">TagWalker</a> tw(ws,hps[i]);</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="keyword">auto</span> ct= tw.remove_crosstalk();</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        <span class="keywordflow">if</span> (ct&gt;0.01) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="keyword">auto</span> wp=tw.walk(.98,.02);</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="keyword">auto</span> parallelpaths=<a class="code" href="class_untangler.html#a7e753ec445e5d8e0c99e4fc5d9df2722">make_parallel_paths</a>(wp);</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        <span class="comment">//tw.dump_reads(&quot;HPSNP_&quot;+std::to_string(llabs(hp.first))+&quot;_&quot;+std::to_string(llabs(hp.second)));</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        <span class="comment">//walk_from(hp.first,ws);</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="comment">//walk_from(hp.second,ws);</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="preprocessor">#pragma omp critical (print_paths)</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="preprocessor"></span>        {</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            <span class="comment">//std::cout &lt;&lt; std::endl &lt;&lt; &quot;PATH A (&quot; &lt;&lt; wp[0].get_sequence().size() &lt;&lt; &quot; bp): &quot;;</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            <span class="comment">//for (auto n:wp[0].nodes) std::cout &lt;&lt; &quot;seq&quot; &lt;&lt; llabs(n) &lt;&lt; &quot;, &quot;;</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <span class="comment">//std::cout &lt;&lt; std::endl &lt;&lt; &quot;PATH B (&quot; &lt;&lt; wp[1].get_sequence().size() &lt;&lt; &quot; bp): &quot;;</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            <span class="comment">//for (auto n:wp[1].nodes) std::cout &lt;&lt; &quot;seq&quot; &lt;&lt; llabs(n) &lt;&lt; &quot;, &quot;;</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;            <span class="comment">//std::cout &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;            <span class="keywordflow">if</span> (parallelpaths[0].getNodes().size()&lt;4 or not <a class="code" href="class_untangler.html#a6b564f0a5d4ed85ef1f2e25bcb894853">all_nodes_consumed</a>(parallelpaths)){</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                <span class="comment">//std::cout &lt;&lt; std::endl &lt;&lt;&quot;NO ALL-CONSUMING PARALLEL PATHS&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            }</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                new_ppaths.emplace_back(parallelpaths);</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                <span class="comment">//std::cout &lt;&lt; &quot;PARALLEL PATHS #&quot;&lt;&lt;new_ppaths.size()-1;</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                <span class="comment">//std::cout &lt;&lt; std::endl &lt;&lt; &quot;PARALLEL PATH A (&quot; &lt;&lt; parallelpaths[0].get_sequence().size() &lt;&lt; &quot; bp): &quot;;</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                <span class="comment">//for (auto n:parallelpaths[0].nodes) std::cout &lt;&lt; &quot;seq&quot; &lt;&lt; llabs(n) &lt;&lt; &quot;, &quot;;</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                <span class="comment">//std::cout &lt;&lt; std::endl &lt;&lt; &quot;PARALLEL PATH B (&quot; &lt;&lt; parallelpaths[1].get_sequence().size() &lt;&lt; &quot; bp): &quot;;</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                <span class="comment">//for (auto n:parallelpaths[1].nodes) std::cout &lt;&lt; &quot;seq&quot; &lt;&lt; llabs(n) &lt;&lt; &quot;, &quot;;</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                <span class="comment">//std::cout &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;            }</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        }</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    }</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="comment">//get the &quot;best neighbour&quot; for each pp</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment">//    for (auto i1=0;i1&lt;new_ppaths.size();++i1){</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">//        for (auto i2=i1+1;i2&lt;new_ppaths.size();++i2){</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment">//            auto shared=shared_nodes({new_ppaths[i1],new_ppaths[i2]});</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">//            if (shared.size()&gt;1) {</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">//                std::cout&lt;&lt;&quot;Parallel paths #&quot;&lt;&lt;i1&lt;&lt;&quot; and #&quot;&lt;&lt;i2&lt;&lt;&quot; share &quot;&lt;&lt;shared.size()&lt;&lt;&quot; nodes&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">//            }</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">//        }</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="comment">//execute merging/conflict</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="comment">//now join the paths that survived</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    std::sort(new_ppaths.begin(),new_ppaths.end(),</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;              [](<span class="keyword">const</span> std::vector&lt;SequenceGraphPath&gt; &amp;a,<span class="keyword">const</span> std::vector&lt;SequenceGraphPath&gt; &amp;b)</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;              {<span class="keywordflow">return</span> a[0].getNodes().size()&gt;b[0].getNodes().size();});</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    std::vector&lt;bool&gt; used(ws.getGraph().nodes.size());</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> pp:new_ppaths){</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        <span class="keywordflow">if</span> (pp[0].getNodes().size()&lt;4) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="keywordtype">bool</span> skip=<span class="keyword">false</span>;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p:pp) <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:p.getNodes()) <span class="keywordflow">if</span> (used[llabs(n)]) {skip=<span class="keyword">true</span>; <span class="keywordflow">break</span>;}</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="keywordflow">if</span> (skip) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;JOINING PARALLEL PATHS #&quot;</span>&lt;&lt;new_ppaths.size()-1;</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;PARALLEL PATH A (&quot;</span> &lt;&lt; pp[0].get_sequence().size() &lt;&lt; <span class="stringliteral">&quot; bp): &quot;</span>;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:pp[0].getNodes()) std::cout &lt;&lt; <span class="stringliteral">&quot;seq&quot;</span> &lt;&lt; llabs(n) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;PARALLEL PATH B (&quot;</span> &lt;&lt; pp[1].get_sequence().size() &lt;&lt; <span class="stringliteral">&quot; bp): &quot;</span>;</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:pp[1].getNodes()) std::cout &lt;&lt; <span class="stringliteral">&quot;seq&quot;</span> &lt;&lt; llabs(n) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        std::cout &lt;&lt; std::endl;</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p:pp) {</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;            std::vector&lt;sgNodeID_t&gt; middle_nodes;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> it=p.getNodes().begin()+1;it&lt;p.getNodes().end()-1;++it) middle_nodes.push_back(*it);</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:middle_nodes) used[llabs(n)]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;            ws.getGraph().<a class="code" href="class_sequence_graph.html#ad7f54e2a8e0a2e74ee21af581ce82c84">join_path</a>(<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(ws.getGraph(),middle_nodes),<span class="keyword">true</span>);</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        }</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    }</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    ws.getGraph().write_to_gfa(<span class="stringliteral">&quot;graph_after_joining_walks.gfa&quot;</span>);</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    ws.getLinkedReadMappers()[0].remove_obsolete_mappings();</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    ws.getGraph().<a class="code" href="class_sequence_graph.html#a84b8d6ab28c22c20a468b1743796d4b0">create_index</a>();</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    ws.getLinkedReadMappers()[0].map_reads();</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    ws.getKCI().reindex_graph();</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;}</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div>
<div class="line"><a name="l00369"></a><span class="lineno"><a class="line" href="class_untangler.html#a7e753ec445e5d8e0c99e4fc5d9df2722">  369</a></span>&#160;std::vector&lt;SequenceGraphPath&gt; <a class="code" href="class_untangler.html#a7e753ec445e5d8e0c99e4fc5d9df2722">Untangler::make_parallel_paths</a>(std::vector&lt;SequenceGraphPath&gt; paths){</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    sgNodeID_t source=0,sink=0;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> na:paths[0].getNodes()){</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        <span class="keywordtype">bool</span> missing=<span class="keyword">false</span>;</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> op=paths.begin()+1;op&lt;paths.end();++op)</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;            <span class="keywordflow">if</span> (std::find(op-&gt;getNodes().begin(),op-&gt;getNodes().end(),na)==op-&gt;getNodes().end()) {</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                missing=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;            }</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        <span class="keywordflow">if</span> (missing) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keywordflow">if</span> (source==0) source=na;</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        sink=na;</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    }</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    std::vector&lt;SequenceGraphPath&gt; pp;</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:paths){</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        pp.emplace_back(ws.getGraph());</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <span class="keywordtype">bool</span> started=<span class="keyword">false</span>,finished=<span class="keyword">false</span>;</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:p.getNodes()){</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;            <span class="keywordflow">if</span> (n==source) started=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            <span class="keywordflow">if</span>(started and not finished) pp.back().getNodes().emplace_back(n);</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            <span class="keywordflow">if</span> (n==sink) finished=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        }</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    }</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="keywordflow">return</span> pp;</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;}</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div>
<div class="line"><a name="l00399"></a><span class="lineno"><a class="line" href="class_untangler.html#a6b564f0a5d4ed85ef1f2e25bcb894853">  399</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="class_untangler.html#a6b564f0a5d4ed85ef1f2e25bcb894853">Untangler::all_nodes_consumed</a>(std::vector&lt;SequenceGraphPath&gt; parallel_paths){</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    std::unordered_set&lt;sgNodeID_t&gt; all_nodes;</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p:parallel_paths) <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;n:p.getNodes()) {all_nodes.insert(n);all_nodes.insert(-n);}</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p:parallel_paths){</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> ix=p.getNodes().begin()+1;ix&lt;p.getNodes().end()-1;++ix) {</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> fc:ws.getGraph().<a class="code" href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">get_fw_links</a>(*ix))<span class="keywordflow">if</span> (all_nodes.count(fc.dest) == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> bc:ws.getGraph().<a class="code" href="class_sequence_graph.html#a8429832b3d8f54b51dc42e444f7e6191">get_bw_links</a>(*ix))<span class="keywordflow">if</span> (all_nodes.count(bc.dest) == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        }</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    }</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;}</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;std::vector&lt;sgNodeID_t&gt; Untangler::shared_nodes(std::vector&lt;std::vector&lt;SequenceGraphPath&gt;&gt; parallel_paths){</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    std::set&lt;sgNodeID_t&gt; seen_nodes, current_nodes, shared;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    std::vector&lt;sgNodeID_t &gt; r;</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    <span class="comment">//checks if any of the nodes are present in more than 1 of the PP</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;pp:parallel_paths){</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        current_nodes.clear();</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p:pp) <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:p.getNodes()) current_nodes.insert(llabs(n));</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        std::set_intersection(seen_nodes.begin(),seen_nodes.end(),current_nodes.begin(),current_nodes.end(),std::inserter(shared,shared.end()));</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;n:current_nodes) seen_nodes.insert(n);</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    }</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:shared) r.emplace_back(n);</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="keywordflow">return</span> r;</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;}</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;</div>
<div class="line"><a name="l00431"></a><span class="lineno"><a class="line" href="class_untangler.html#a4a0342058888dad2d987251ddef5d108">  431</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="class_untangler.html#a4a0342058888dad2d987251ddef5d108">Untangler::analise_paths_through_nodes</a>() {</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="keyword">auto</span> kci(ws.getKCI());</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;computing KCI for all nodes&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    ws.getKCI().compute_all_nodes_kci(1);</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    std::ofstream kciof(<span class="stringliteral">&quot;kci_dump.csv&quot;</span>);</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=1;i&lt;ws.getGraph().nodes.size();++i) kciof&lt;&lt;<span class="stringliteral">&quot;seq&quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;kci.nodes_depth[i]&lt;&lt;std::endl;</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;DONE!&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="comment">//CRAP regions</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    std::vector&lt;bool&gt; used(ws.getGraph().nodes.size(),<span class="keyword">false</span>),aborted(ws.getGraph().nodes.size(),<span class="keyword">false</span>);</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    std::vector&lt;SequenceSubGraph&gt; craps;</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    <span class="keywordflow">for</span> (sgNodeID_t n=1;n&lt;ws.getGraph().nodes.size();++n) {</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        <span class="keywordflow">if</span> (used[n]) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        <span class="keywordflow">if</span> (kci.nodes_depth[n]&lt;1.5 and ws.getGraph().nodes[n].sequence.size()&gt;500) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        <a class="code" href="class_sequence_sub_graph.html">SequenceSubGraph</a> crap(ws.getGraph());</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        std::vector&lt;sgNodeID_t&gt; to_explore={n};</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        std::cout&lt;&lt;<span class="stringliteral">&quot;Exploring node &quot;</span>&lt;&lt;n&lt;&lt;std::endl;</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        <span class="keywordflow">while</span> (!to_explore.empty()){</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            std::vector&lt;sgNodeID_t&gt; new_to_explore;</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;            <span class="comment">//std::cout&lt;&lt;&quot; Exploring &quot;&lt;&lt;to_explore.size()&lt;&lt; &quot; neighbors&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> ne:to_explore){</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                <span class="comment">//std::cout&lt;&lt;&quot;  Exploring node #&quot;&lt;&lt;ne&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> neigh:ws.getGraph().<a class="code" href="class_sequence_graph.html#a254a345ad26431edfcedb2c7565a6358">links</a>[ne]){</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                    <span class="keyword">auto</span> x=llabs(neigh.dest);</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                    <span class="comment">//std::cout&lt;&lt;&quot;  Exploring neighbour #&quot;&lt;&lt;x&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                    <span class="keywordflow">if</span> (std::find(crap.nodes.begin(),crap.nodes.end(),x)==crap.nodes.end()) {</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                        <span class="comment">//std::cout&lt;&lt;&quot;  ADDING to crap!&quot;&lt;&lt;x&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                        crap.nodes.emplace_back(x);</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                        <span class="keywordflow">if</span> (not (kci.nodes_depth[x]&lt;1.5 and ws.getGraph().nodes[x].sequence.size()&gt;500)) {</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                            <span class="comment">//std::cout&lt;&lt;&quot;  ADDING to explore list (size=&quot;&lt;&lt;ws.sg.nodes[x].sequence.size()&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                            new_to_explore.emplace_back(x);</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;                        }</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                    }</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                }</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;            }</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;            <span class="comment">//std::cout&lt;&lt;new_to_explore.size()&lt;&lt; &quot; new neighbors to explore on the next round&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;            to_explore=new_to_explore;</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;            <span class="keywordflow">if</span> (crap.nodes.size()&gt;5000) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        }</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        <span class="keywordflow">if</span> (crap.nodes.size()&gt;10) {</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;x:crap.nodes) used[x]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;            <span class="keywordflow">if</span> (crap.nodes.size()&lt;=5000) {</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                craps.emplace_back(crap);</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;==== NEW CRAP ====&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> x:crap.nodes) std::cout &lt;&lt; <span class="stringliteral">&quot;seq&quot;</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                std::cout &lt;&lt; std::endl;</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;            }</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            <span class="keywordflow">if</span> (crap.nodes.size()&gt;5000) {</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> x:crap.nodes) aborted[x]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            }</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        }</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    }</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    uint64_t abt=0;</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> a:aborted) <span class="keywordflow">if</span> (a) ++abt;</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;There were &quot;</span>&lt;&lt;abt&lt;&lt;<span class="stringliteral">&quot; nodes in aborted crap components&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;}</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;std::vector&lt;std::pair&lt;sgNodeID_t,sgNodeID_t&gt;&gt; Untangler::find_bubbles(uint32_t min_size,uint32_t max_size) {</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    std::vector&lt;std::pair&lt;sgNodeID_t,sgNodeID_t&gt;&gt; r;</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    std::vector&lt;bool&gt; used(ws.getGraph().nodes.size(),<span class="keyword">false</span>);</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    sgNodeID_t n1,n2;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    <span class="keywordtype">size_t</span> s1,s2;</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="keywordflow">for</span> (n1=1;n1&lt;ws.getGraph().nodes.size();++n1){</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        <span class="keywordflow">if</span> (used[n1]) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        <span class="comment">//get &quot;topologically correct&quot; bubble: prev -&gt; [n1 | n2] -&gt; next</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        s1=ws.getGraph().nodes[n1].sequence.size();</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        <span class="keywordflow">if</span> (s1&lt;min_size or s1&gt;max_size) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        <span class="keyword">auto</span> fwl=ws.getGraph().<a class="code" href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">get_fw_links</a>(n1);</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        <span class="keywordflow">if</span> (fwl.size()!=1) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        <span class="keyword">auto</span> next=fwl[0].dest;</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        <span class="keyword">auto</span> bwl=ws.getGraph().<a class="code" href="class_sequence_graph.html#a8429832b3d8f54b51dc42e444f7e6191">get_bw_links</a>(n1);</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        <span class="keywordflow">if</span> (bwl.size()!=1) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        <span class="keyword">auto</span> prev=bwl[0].dest;</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        <span class="keyword">auto</span> parln=ws.getGraph().<a class="code" href="class_sequence_graph.html#a8429832b3d8f54b51dc42e444f7e6191">get_bw_links</a>(next);</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        <span class="keywordflow">if</span> (parln.size()!=2) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        <span class="keyword">auto</span> parlp=ws.getGraph().<a class="code" href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">get_fw_links</a>(-prev);</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        <span class="keywordflow">if</span> (parlp.size()!=2) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        <span class="keywordflow">if</span> (parlp[0].dest!=n1) n2=parlp[0].dest;</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        <span class="keywordflow">else</span> n2=parlp[1].dest;</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        <span class="keywordflow">if</span> (n2!=-parln[0].dest and n2!=-parln[1].dest) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        s2=ws.getGraph().nodes[n2].sequence.size();</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        <span class="keywordflow">if</span> (s2&lt;min_size or s2&gt;max_size) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;        used[n1]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        used[n2]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        r.emplace_back(n1,n2);</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    }</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    <span class="keywordflow">return</span> r;</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;}</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div>
<div class="line"><a name="l00526"></a><span class="lineno"><a class="line" href="class_untangler.html#a85c068929740a3c37eacc1558c0f9e66">  526</a></span>&#160;std::pair&lt;SequenceGraphPath,SequenceGraphPath&gt; <a class="code" href="class_untangler.html#a85c068929740a3c37eacc1558c0f9e66">Untangler::solve_bubbly_path</a>(<span class="keyword">const</span> <a class="code" href="class_sequence_sub_graph.html">SequenceSubGraph</a> &amp;bp, <span class="keywordtype">bool</span> &amp;no_tags) {</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    <span class="keyword">auto</span> linked_read_mappers(ws.getLinkedReadMappers());</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    <span class="keywordtype">int</span> min_tags=20; no_tags=<span class="keyword">false</span>;</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    std::vector&lt;std::set&lt;bsg10xTag&gt;&gt; node_tags;</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=0;i&lt;bp.nodes.size();++i) {</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;        <span class="keyword">auto</span> n=bp.nodes[i];</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;        node_tags.emplace_back(linked_read_mappers[0].get_node_tags(n));</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        <span class="keywordflow">if</span> (i%3&gt;0 and node_tags.back().size()&lt;min_tags) {</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;            no_tags=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;            <span class="keywordflow">return</span> {<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(ws.getGraph()),<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(ws.getGraph())};</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;        };<span class="comment">//check failed: min-tags</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    }</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    <span class="comment">//init the haplotypes anchoring all nodes to previous tags</span></div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <span class="comment">//std::cout&lt;&lt;&quot;A&quot;;</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    std::vector&lt;sgNodeID_t&gt; hap1, hap2;</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    std::set&lt;bsg10xTag&gt; tags1,tags2;</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    hap1.push_back(bp.nodes[1]);</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    tags1=node_tags[1];</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    hap2.push_back(bp.nodes[2]);</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    tags2=node_tags[2];</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=3;i&lt;bp.nodes.size()-1;i+=3){</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;        std::set&lt;bsg10xTag&gt; both;</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;        std::set_intersection(tags1.begin(),tags1.end(),tags2.begin(),tags2.end(),std::inserter(both,both.end()));</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> b:both){</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;            tags1.erase(b);</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;            tags2.erase(b);</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        }</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;        <span class="keyword">auto</span> A=bp.nodes[i+1];</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        <span class="keyword">auto</span> B=bp.nodes[i+2];</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;        <span class="keyword">auto</span> tagsA=linked_read_mappers[0].get_node_tags(A);</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        <span class="keyword">auto</span> tagsB=linked_read_mappers[0].get_node_tags(B);</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        <span class="keyword">auto</span> a1=intersection_size(tagsA,tags1);</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        <span class="keyword">auto</span> a2=intersection_size(tagsA,tags2);</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="keyword">auto</span> b1=intersection_size(tagsB,tags1);</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;        <span class="keyword">auto</span> b2=intersection_size(tagsB,tags2);</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        <span class="keywordflow">if</span> (a1&gt;=min_tags and b1&lt;a1*2/min_tags and b2&gt;=min_tags and a2&lt;b2*2/min_tags){</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            hap1.push_back(A);</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;            tags1.insert(tagsA.begin(),tagsA.end());</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            hap2.push_back(B);</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;            tags2.insert(tagsB.begin(),tagsB.end());</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        }</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b1&gt;=min_tags and a1&lt;b1*2/min_tags and a2&gt;=min_tags and b2&lt;a2*2/min_tags){</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;            hap2.push_back(A);</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            tags2.insert(tagsA.begin(),tagsA.end());</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;            hap1.push_back(B);</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;            tags1.insert(tagsB.begin(),tagsB.end());</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        }</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    }</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    <span class="comment">//std::cout&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    <span class="keywordflow">if</span> (hap1.size()==bp.nodes.size()/3) {</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        <a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a> p1(ws.getGraph()),p2(ws.getGraph());</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=0;i&lt;hap1.size();++i){</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;            <span class="keywordflow">if</span> (i&gt;0) p1.getNodes().push_back(bp.nodes[3*i]);</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;            p1.getNodes().push_back(hap1[i]);</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;            <span class="keywordflow">if</span> (i&gt;0) p2.getNodes().push_back(bp.nodes[3*i]);</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;            p2.getNodes().push_back(hap2[i]);</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;        }</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        <span class="keywordflow">return</span> {p1,p2};</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    }</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    <span class="keywordflow">return</span> {<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(ws.getGraph()),<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(ws.getGraph())};</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;}</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;</div>
<div class="line"><a name="l00597"></a><span class="lineno"><a class="line" href="class_untangler.html#a89273e74b00b26fc5d18c26340fc1225">  597</a></span>&#160;std::vector&lt;std::pair&lt;SequenceGraphPath,SequenceGraphPath&gt;&gt; <a class="code" href="class_untangler.html#a89273e74b00b26fc5d18c26340fc1225">Untangler::solve_bubbly_path_2</a>(<span class="keyword">const</span> <a class="code" href="class_sequence_sub_graph.html">SequenceSubGraph</a> &amp;bp) {</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="keyword">auto</span> linked_read_mappers(ws.getLinkedReadMappers());</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    std::cout&lt;&lt;std::endl&lt;&lt;<span class="stringliteral">&quot;solve_bubbly_path_2 started for &quot;</span>&lt;&lt;bp.nodes.size()&lt;&lt;<span class="stringliteral">&quot; nodes (&quot;</span>&lt;&lt;bp.nodes.size()/3&lt;&lt;<span class="stringliteral">&quot; bubbles)&quot;</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;             &lt;&lt;<span class="stringliteral">&quot;between &quot;</span>&lt;&lt;bp.nodes.front()&lt;&lt;<span class="stringliteral">&quot; and &quot;</span>&lt;&lt;bp.nodes.back()&lt;&lt;std::endl;</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;Nodes in bubbly path:&quot;</span>;</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;    <span class="keywordflow">for</span>(<span class="keyword">auto</span> n:bp.nodes) std::cout&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;n;</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    std::cout&lt;&lt;std::endl;</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;    <span class="comment">//CONSTANTS</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;    <span class="keywordtype">int</span> specific_to_shared_tags=100;</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;    <span class="keywordtype">size_t</span> min_score=10;</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    <span class="keywordtype">size_t</span> max_penalty=3;</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    std::set&lt;std::pair&lt;sgNodeID_t, sgNodeID_t&gt;&gt; solution;</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    std::map&lt;sgNodeID_t,std::set&lt;bsg10xTag&gt;&gt; node_tags;</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;    std::set&lt;std::pair&lt;sgNodeID_t, sgNodeID_t&gt;&gt; pnps; <span class="comment">//Parallel Node Pairs</span></div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;    <span class="comment">//non-positional best beighbours first: create a set of all PNPs, pick the starting one (highest with up to .5%shared tags</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;    <span class="comment">//TODO:prioritise clean start (shared=0)</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;    <span class="keywordtype">size_t</span> max_min_tags=0;</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    std::pair&lt;sgNodeID_t, sgNodeID_t&gt; best_start;</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=0;i&lt;bp.nodes.size()-1;i+=3){</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;        <span class="keyword">auto</span> A=bp.nodes[i+1];</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;        <span class="keyword">auto</span> B=bp.nodes[i+2];</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;        node_tags[A]=linked_read_mappers[0].get_node_tags(A);</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;        node_tags[B]=linked_read_mappers[0].get_node_tags(B);</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        pnps.insert({A,B});</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;        <span class="keyword">auto</span> shared_count=intersection_size(node_tags[A],node_tags[B]);</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;        <span class="keywordflow">if</span> (shared_count*specific_to_shared_tags&lt;node_tags[A].size() and shared_count*specific_to_shared_tags&lt;node_tags[B].size() and max_min_tags&lt;std::min(node_tags[A].size(),node_tags[B].size())){</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;            best_start.first=A;best_start.second=B;</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;            max_min_tags=std::min(node_tags[A].size(),node_tags[B].size());</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;        }</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        std::cout&lt;&lt;<span class="stringliteral">&quot; bubble tag analysis: A=&quot;</span>&lt;&lt;A&lt;&lt;<span class="stringliteral">&quot;: &quot;</span>&lt;&lt;node_tags[A].size()&lt;&lt;<span class="stringliteral">&quot; B=&quot;</span>&lt;&lt;B&lt;&lt;<span class="stringliteral">&quot;: &quot;</span>&lt;&lt;node_tags[B].size()&lt;&lt;<span class="stringliteral">&quot;  shared: &quot;</span>&lt;&lt;shared_count&lt;&lt;std::endl;</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;    }</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    <span class="keywordflow">if</span> (max_min_tags==0){</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        std::cout&lt;&lt;<span class="stringliteral">&quot;can&#39;t even find where to start, so giving up&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;        <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    }</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;starting from PNP &quot;</span>&lt;&lt;best_start.first&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;best_start.second&lt;&lt;std::endl;</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    <span class="keyword">auto</span> tags1=node_tags[best_start.first];</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;    <span class="keyword">auto</span> tags2=node_tags[best_start.second];</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    <span class="keyword">auto</span> total_penalty=intersection_size(tags1,tags2);</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;    <span class="keyword">auto</span> todo_pnps=pnps;</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;    todo_pnps.erase(best_start);</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    solution.insert(best_start);</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    <span class="comment">// while possible grab the next lowest-conflict/highest score PNP</span></div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    <span class="keywordflow">while</span> (not todo_pnps.empty()){</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;        <span class="keywordtype">size_t</span> min_pen=max_penalty;</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;        <span class="keywordtype">size_t</span> max_score=0;</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;        std::pair&lt;sgNodeID_t, sgNodeID_t&gt; best_next;</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;        <span class="keywordtype">bool</span> flip=<span class="keyword">false</span>;</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:todo_pnps){</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;            <span class="keyword">auto</span> a1=intersection_size(node_tags[p.first],tags1);</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;            <span class="keyword">auto</span> a2=intersection_size(node_tags[p.first],tags2);</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;            <span class="keyword">auto</span> b1=intersection_size(node_tags[p.second],tags1);</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;            <span class="keyword">auto</span> b2=intersection_size(node_tags[p.second],tags2);</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;            <span class="comment">//std::cout&lt;&lt;&quot;evaluating PNP (&quot;&lt;&lt;p.first&lt;&lt;&quot;, &quot;&lt;&lt;p.second&lt;&lt;&quot;) : a1=&quot;&lt;&lt;a1&lt;&lt;&quot; a2=&quot;&lt;&lt;a2&lt;&lt;&quot; b1=&quot;&lt;&lt;b1&lt;&lt;&quot; b2=&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;            <span class="comment">//TODO: discount already-shared tags from penalty;</span></div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;            <span class="comment">//dir?</span></div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;            <span class="keywordflow">if</span> (a1&gt;min_score and b2&gt; min_score and (a2+b1&lt;min_pen or ( a2+b1==min_pen and a1+b2&gt;max_score))) {</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                best_next.first=p.first;best_next.second=p.second;flip=<span class="keyword">false</span>;</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                min_pen=a2+b1;</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                max_score=a1+b2;</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;            }</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;            <span class="comment">//flip?</span></div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a2&gt;min_score and b1&gt; min_score and (a1+b2&lt;min_pen or( a1+b2==min_pen and a2+b1&gt;max_score))) {</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                best_next.first=p.first;best_next.second=p.second;flip=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                min_pen=a1+b2;</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                max_score=a2+b1;</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;            }</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;        }</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;        <span class="keywordflow">if</span> (max_score==0) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;        todo_pnps.erase(best_next);</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;        <span class="keywordflow">if</span> (flip) { <span class="keyword">auto</span> s=best_next.second;best_next.second=best_next.first;best_next.first=s; }</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        solution.insert(best_next);</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:node_tags[best_next.first]) tags1.insert(t);</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:node_tags[best_next.second]) tags2.insert(t);</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    }</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    <span class="comment">// rescue PNPs without tags for a node (contemplate both error AA BB and non-mappable node walk)</span></div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;    std::unordered_set&lt;uint64_t&gt; tagkmers1,tagkmers2;</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">false</span><span class="comment">/*not todo_pnps.empty()*/</span>) {</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;        std::cout&lt;&lt;<span class="stringliteral">&quot;Solution is incomplete, attempting PNP rescue for untagged nodes and sequencing errors&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;        std::set&lt;std::pair&lt;sgNodeID_t ,sgNodeID_t &gt;&gt; rescued;</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:todo_pnps) {</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;            <span class="keyword">auto</span> a1=intersection_size(node_tags[p.first],tags1);</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;            <span class="keyword">auto</span> a2=intersection_size(node_tags[p.first],tags2);</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;            <span class="keyword">auto</span> b1=intersection_size(node_tags[p.second],tags1);</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;            <span class="keyword">auto</span> b2=intersection_size(node_tags[p.second],tags2);</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;            std::cout&lt;&lt;<span class="stringliteral">&quot;Checking PNP ( &quot;</span>&lt;&lt;p.first&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;p.second&lt;&lt;<span class="stringliteral">&quot; ): a1=&quot;</span>&lt;&lt;a1&lt;&lt;<span class="stringliteral">&quot; a2=&quot;</span>&lt;&lt;a2&lt;&lt;<span class="stringliteral">&quot; b1=&quot;</span>&lt;&lt;b1&lt;&lt;<span class="stringliteral">&quot; b2=&quot;</span>&lt;&lt;b2&lt;&lt;std::endl;</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;            <span class="keywordflow">if</span> (a1&gt;10 and a2&gt;10 and b1&lt;3 and b2&lt;3) {</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;                std::cout&lt;&lt;<span class="stringliteral">&quot;Node &quot;</span>&lt;&lt;p.second&lt;&lt;<span class="stringliteral">&quot; seems to be an error!&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;                solution.insert({p.first,p.first});</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;                rescued.insert(p);</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;            }</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;            <span class="keywordflow">if</span> (b1&gt;10 and b2&gt;10 and a1&lt;3 and a2&lt;3) {</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;                std::cout&lt;&lt;<span class="stringliteral">&quot;Node &quot;</span>&lt;&lt;p.first&lt;&lt;<span class="stringliteral">&quot; seems to be an error!&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;                solution.insert({p.second,p.second});</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;                rescued.insert(p);</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;            }</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;            <span class="comment">//now check for untagged (i.e. kmer coverage)</span></div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;            <span class="keywordflow">if</span> (tagkmers1.empty()){</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;                std::cout&lt;&lt;<span class="stringliteral">&quot;Generating tag kmers for current solution as this is the first walk-in situation&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;                <a class="code" href="class_buffered_tag_kmerizer.html">BufferedTagKmerizer</a> btk(ws.getLinkedReadDatastores()[0],31,200000,1000);</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;                std::set&lt;bsg10xTag&gt; exctags1,exctags2;</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:tags1) <span class="keywordflow">if</span> (tags2.count(t)==0) exctags1.insert(t);</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:tags2) <span class="keywordflow">if</span> (tags1.count(t)==0) exctags2.insert(t);</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;                tagkmers1=btk.get_tags_kmers(6, exctags1);</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;                tagkmers2=btk.get_tags_kmers(6, exctags2);</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;            }</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;            <a class="code" href="class_string_k_mer_factory.html">StringKMerFactory</a> kfa(sg.nodes[llabs(p.first)].sequence,31);</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;            <a class="code" href="class_string_k_mer_factory.html">StringKMerFactory</a> kfb(sg.nodes[llabs(p.second)].sequence,31);</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;            std::vector&lt;uint64_t&gt; ka,kb;</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;            kfa.<a class="code" href="class_string_k_mer_factory.html#aff34d2ccaa9d9ddda612f760cb470979">create_kmers</a>(ka);</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;            kfb.<a class="code" href="class_string_k_mer_factory.html#aff34d2ccaa9d9ddda612f760cb470979">create_kmers</a>(kb);</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;            uint64_t uncovered_a1=0,uncovered_a2=0,uncovered_b1=0,uncovered_b2=0;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> x:ka) {</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;                <span class="keywordflow">if</span> (tagkmers1.count(x)==0) ++uncovered_a1;</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;                <span class="keywordflow">if</span> (tagkmers2.count(x)==0) ++uncovered_a2;</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;            }</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> x:kb) {</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;                <span class="keywordflow">if</span> (tagkmers1.count(x)==0) ++uncovered_b1;</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;                <span class="keywordflow">if</span> (tagkmers2.count(x)==0) ++uncovered_b2;</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;            }</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;            std::cout&lt;&lt;<span class="stringliteral">&quot;kmers not covered by haplotype-specific tags: a~1=&quot;</span>&lt;&lt;uncovered_a1&lt;&lt;<span class="stringliteral">&quot; a~2=&quot;</span>&lt;&lt;uncovered_a2&lt;&lt;<span class="stringliteral">&quot; b~1=&quot;</span>&lt;&lt;uncovered_b1&lt;&lt;<span class="stringliteral">&quot; b~2=&quot;</span>&lt;&lt;uncovered_b2&lt;&lt;std::endl;</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;            <span class="keywordflow">if</span> (uncovered_a1==0 and uncovered_b1&gt;0 and uncovered_b2==0 and uncovered_a2&gt;0) {</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;                std::cout&lt;&lt;<span class="stringliteral">&quot;PNP ( &quot;</span>&lt;&lt;p.first&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;p.second&lt;&lt;<span class="stringliteral">&quot; ) walked-through as AB!&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;                solution.insert({p.first,p.second});</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;                rescued.insert(p);</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;            }</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;            <span class="keywordflow">if</span> (uncovered_a2==0 and uncovered_b2&gt;0 and uncovered_b1==0 and uncovered_a1&gt;0) {</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;                std::cout&lt;&lt;<span class="stringliteral">&quot;PNP ( &quot;</span>&lt;&lt;p.first&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;p.second&lt;&lt;<span class="stringliteral">&quot; ) walked-through as BA!&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;                solution.insert({p.second,p.first});</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;                rescued.insert(p);</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;            }</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;        }</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:rescued) todo_pnps.erase(p);</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    }</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;Hap1: &quot;</span>;</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:solution) std::cout&lt;&lt;<span class="stringliteral">&quot;seq&quot;</span>&lt;&lt;llabs(p.first)&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;    std::cout&lt;&lt;std::endl&lt;&lt;<span class="stringliteral">&quot;Hap2: &quot;</span>;</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:solution) std::cout&lt;&lt;<span class="stringliteral">&quot;seq&quot;</span>&lt;&lt;llabs(p.second)&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;    std::cout&lt;&lt;std::endl;</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;    std::vector&lt;std::pair&lt;SequenceGraphPath,SequenceGraphPath&gt;&gt; paths;</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;    <span class="keywordflow">if</span> (todo_pnps.empty()) {</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;FULL SOLUTION found!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;        std::cout&lt;&lt;<span class="stringliteral">&quot;SOLUTION only contains &quot;</span>&lt;&lt;solution.size()&lt;&lt;<span class="stringliteral">&quot;/&quot;</span>&lt;&lt;pnps.size()&lt;&lt;<span class="stringliteral">&quot; PNPs&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        <span class="comment">//TODO support partial solutions! (i.e. re-run with broken bubbly path?)</span></div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;        std::cout&lt;&lt;<span class="stringliteral">&quot;Generating partial solutions&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;    }</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;    std::set&lt;sgNodeID_t&gt; h1nodes,h2nodes;</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:solution) {</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;        h1nodes.insert(p.first);</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;        h2nodes.insert(p.second);</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;    }</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;    std::vector&lt;sgNodeID_t&gt; currh1,currh2;</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=0;i&lt;bp.nodes.size();++i){</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;        <span class="keywordflow">if</span> (i%3==0 ){</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;            <span class="keywordflow">if</span> (not currh1.empty()) {</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                <span class="keywordflow">if</span> (i &lt; bp.nodes.size() - 3 and</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                    (h1nodes.count(bp.nodes[i + 1]) &gt; 0 or h2nodes.count(bp.nodes[i + 1]) &gt; 0) and</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;                    (h1nodes.count(bp.nodes[i + 2]) &gt; 0 or h2nodes.count(bp.nodes[i + 2]) &gt; 0)) {</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;                    currh1.emplace_back(bp.nodes[i]);</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;                    currh2.emplace_back(bp.nodes[i]);</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;                    <span class="keywordflow">if</span> (currh1.size() &gt; 2) {</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;                        std::cout &lt;&lt; <span class="stringliteral">&quot;Solution #&quot;</span> &lt;&lt; paths.size() + 1 &lt;&lt; <span class="stringliteral">&quot;.a:&quot;</span>;</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:currh1) std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; n;</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                        std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Solution #&quot;</span> &lt;&lt; paths.size() + 1 &lt;&lt; <span class="stringliteral">&quot;.b:&quot;</span>;</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:currh2) std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; n;</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                        std::cout &lt;&lt; std::endl;</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;                        paths.push_back({<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(sg, currh1), <a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>(sg, currh2)});</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;                    }</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;                    currh1.clear();</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;                    currh2.clear();</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;                }</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;            }</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;            <span class="keywordflow">if</span> (h1nodes.count(bp.nodes[i])&gt;0) currh1.emplace_back(bp.nodes[i]);</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;            <span class="keywordflow">if</span> (h2nodes.count(bp.nodes[i])&gt;0) currh2.emplace_back(bp.nodes[i]);</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;        }</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;    }</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    <span class="comment">//remove last node (heterozygous, we don&#39;t want to stupidly extend haplotypes</span></div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;    <span class="keywordflow">return</span> paths;</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;}</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;</div>
<div class="line"><a name="l00795"></a><span class="lineno"><a class="line" href="class_untangler.html#ae2506fd72b64a11eb91413ef29054a3d">  795</a></span>&#160;std::vector&lt;std::pair&lt;sgNodeID_t,sgNodeID_t&gt;&gt; <a class="code" href="class_untangler.html#ae2506fd72b64a11eb91413ef29054a3d">Untangler::solve_bubbly_paths</a>() {</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;    <a class="code" href="class_kmer_compression_index.html">KmerCompressionIndex</a>&amp; kci(ws.getKCI());</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;    <span class="comment">//TODO: 3-part structure:</span></div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    <span class="comment">// 1) find, report validate kci, report</span></div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;    <span class="comment">// 2) For each: solve</span></div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;    <span class="comment">// 3) report</span></div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;    <span class="comment">//find bubbly paths</span></div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;    <span class="keyword">auto</span> bps=sg.get_all_bubbly_subgraphs();</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;--- INITIAL bubbly paths ---&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;    sg.print_bubbly_subgraph_stats(bps);</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;    <span class="comment">//TODO: write a more sophisticated kci check</span></div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;    std::vector&lt;SequenceSubGraph&gt; kobps;</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;bp:bps){</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;        <span class="keywordtype">int</span> kci_ok=0,kci_fail=0;</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=0;i&lt;bp.nodes.size();i+=3) {</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;            <span class="keyword">auto</span> dup_kci=kci.compute_compression_for_node(bp.nodes[i],1);</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;            <span class="keywordflow">if</span> (dup_kci&lt;1.25 or dup_kci&gt;2.5) ++kci_fail;</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;            <span class="keywordflow">else</span> ++kci_ok;</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;        }</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;        <span class="keywordflow">if</span> (kci_fail*3&lt;kci_ok) {</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;            kobps.push_back(bp);</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;        }</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;    }</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;--- KCI OK bubbly paths ---&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    sg.print_bubbly_subgraph_stats(kobps);</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;    <span class="comment">//uint64_t solved=0, solved_nodes=0, solved_size=0, untagged=0,untagged_nodes=0, untagged_size=0 ,ambiguous=0,ambiguous_nodes=0, ambiguous_size=0;</span></div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    <span class="comment">//std::vector&lt;std::pair&lt;std::vector&lt;sgNodeID_t&gt;,std::vector&lt;sgNodeID_t&gt;&gt;&gt; solved_haps;</span></div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;    <span class="comment">//int min_tags=20;</span></div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    <span class="comment">/*{</span></div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="comment">        uint64_t solved = 0, unsolved = 0, untagged = 0;</span></div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="comment">        std::vector&lt;SequenceSubGraph&gt; solbubs;</span></div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="comment">        for (auto &amp;bp:kobps) {</span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;<span class="comment">            bool no_tags;</span></div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="comment">            auto sol = solve_bubbly_path(bp, no_tags);</span></div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;<span class="comment">            if (no_tags) ++untagged;</span></div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="comment">            if (sol.first.nodes.size() == 0) ++unsolved;</span></div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="comment">            else {</span></div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="comment">                ++solved;</span></div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="comment">                solbubs.push_back(bp);</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="comment">            }</span></div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="comment"></span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="comment">        }</span></div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="comment">        sglib::OutputLog() &lt;&lt; &quot;OLD solver: &quot;&lt;&lt; solved &lt;&lt; &quot; bubbly paths solved, &quot; &lt;&lt; unsolved &lt;&lt; &quot; unsolved, with &quot; &lt;&lt; untagged &lt;&lt; &quot; lacking tags&quot; &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="comment">        ws.sg.print_bubbly_subgraph_stats(solbubs);</span></div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="comment">        //done!</span></div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="comment">    }*/</span></div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;    {</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;        uint64_t solved = 0, unsolved = 0;</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;        std::vector&lt;SequenceSubGraph&gt; solbubs;</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;        std::vector&lt;SequenceGraphPath&gt; paths;</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;bp:kobps) {</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;            <span class="keyword">auto</span> sol = <a class="code" href="class_untangler.html#a89273e74b00b26fc5d18c26340fc1225">solve_bubbly_path_2</a>(bp);</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;            <span class="keywordflow">if</span> (sol.size() == 0) ++unsolved;</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;            <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;                ++solved;</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                solbubs.push_back(bp);</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> pp:sol) {</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;                    paths.push_back(pp.first);</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;                    paths.push_back(pp.second);</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;                }</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;            }</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;        }</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;        sglib::OutputLog() &lt;&lt; <span class="stringliteral">&quot;New solver: &quot;</span>&lt;&lt; solved &lt;&lt; <span class="stringliteral">&quot; bubbly paths solved, &quot;</span> &lt;&lt; unsolved &lt;&lt; <span class="stringliteral">&quot; unsolved&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;        sg.print_bubbly_subgraph_stats(solbubs);</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;        std::set&lt;sgNodeID_t&gt; used_nodes;</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:paths) {</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;            sg.join_path(p,<span class="keyword">false</span>);</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:p.getNodes()) used_nodes.insert(n);</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        }</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:used_nodes) sg.remove_node(n);</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;        <span class="comment">//done!</span></div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;    }</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;    <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;}</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="keywordtype">void</span> Untangler::pop_errors_by_ci_and_paths() {</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;    <a class="code" href="class_kmer_compression_index.html">KmerCompressionIndex</a>&amp; kci(ws.getKCI());</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;Popping errors...&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;    <span class="keyword">auto</span> bubbles=find_bubbles(200, 450);</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;Analysing &quot;</span>&lt;&lt;bubbles.size()&lt;&lt;<span class="stringliteral">&quot; small bubbles for coverage&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;    std::vector&lt;sgNodeID_t&gt; to_delete;</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    std::ofstream bubblesf(<span class="stringliteral">&quot;bubbles_detail.csv&quot;</span>);</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;    bubblesf&lt;&lt;<span class="stringliteral">&quot;prev,b1,b2,next,ci_prev,ci1,ci2,ci_next&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> bp:bubbles){</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;        <span class="keyword">auto</span> ci1=kci.compute_compression_for_node(bp.first,1);</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;        <span class="keyword">auto</span> ci2=kci.compute_compression_for_node(bp.second,1);</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;        <span class="keyword">auto</span> prev=sg.get_bw_links(bp.first)[0].dest;</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;        <span class="keyword">auto</span> next=sg.get_fw_links(bp.first)[0].dest;</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;        <span class="keyword">auto</span> cip=kci.compute_compression_for_node(prev);</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;        <span class="keyword">auto</span> cin=kci.compute_compression_for_node(next);</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;        bubblesf&lt;&lt;prev&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;bp.first&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;bp.second&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;next&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;cip&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;ci1&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;ci2&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;cin&lt;&lt;std::endl;</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;        <span class="keywordflow">if</span> (cip&lt;1.5 and cin&lt;1.5) {</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;            <span class="keywordflow">if</span> (ci1 &gt; .7 and ci2 &lt; .1) {</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; bp.second &lt;&lt; <span class="stringliteral">&quot; has only &quot;</span> &lt;&lt; ci2 &lt;&lt; <span class="stringliteral">&quot; coverage and &quot;</span> &lt;&lt; bp.first &lt;&lt; <span class="stringliteral">&quot; has &quot;</span></div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;                          &lt;&lt; ci1 &lt;&lt; std::endl;</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;                to_delete.push_back(llabs(bp.second));</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;            }</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;            <span class="keywordflow">if</span> (ci2 &gt; .7 and ci1 &lt; .1) {</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; bp.first &lt;&lt; <span class="stringliteral">&quot; has only &quot;</span> &lt;&lt; ci1 &lt;&lt; <span class="stringliteral">&quot; coverage and &quot;</span> &lt;&lt; bp.second &lt;&lt; <span class="stringliteral">&quot; has &quot;</span></div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;                          &lt;&lt; ci2 &lt;&lt; std::endl;</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;                to_delete.push_back(llabs(bp.first));</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;            }</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;        }</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;    }</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;Deleting &quot;</span>&lt;&lt;to_delete.size()&lt;&lt;<span class="stringliteral">&quot; nodes as errors&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;pb:to_delete) sg.remove_node(pb);</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;}</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;</div>
<div class="line"><a name="l00920"></a><span class="lineno"><a class="line" href="class_untangler.html#afd3182e869342c4d435a46bb62b243cd">  920</a></span>&#160;std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t,uint32_t&gt;&gt;&gt; <a class="code" href="class_untangler.html#afd3182e869342c4d435a46bb62b243cd">Untangler::find_tag_neighbours</a>(uint32_t min_size, <span class="keywordtype">float</span> min_ci, <span class="keywordtype">float</span> max_ci) {</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;    std::vector&lt;LinkedReadMapper&gt;&amp; linked_read_mappers(ws.getLinkedReadMappers());</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a> tsg;</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;    std::map&lt;sgNodeID_t,sgNodeID_t&gt; general_to_tag;</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;Selecting selected_nodes...&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;    std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t,uint32_t&gt;&gt;&gt; neighbours;</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;    std::vector&lt;std::set&lt;bsg10xTag&gt;&gt; node_tags;</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;    neighbours.resize(sg.nodes.size());</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;    node_tags.resize(sg.nodes.size());</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;    uint64_t total_bp=0;</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    <span class="keyword">auto</span> selected_nodes=ws.select_from_all_nodes(min_size,1000000,20,200000, min_ci, max_ci);</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;Populating node tags...&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;    uint64_t tag_empty=0, tag_10=0, tag_50=0, tag_100=0, tag_1000=0;</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:selected_nodes) {</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;        general_to_tag[n]=tsg.add_node(sg.nodes[n].sequence);</div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;        total_bp+=sg.nodes[n].sequence.size();</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:linked_read_mappers[0].get_node_tags(n)) node_tags[n].insert(t);</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;        <span class="keywordflow">if</span> (node_tags[n].empty()) ++tag_empty;</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;        <span class="keywordflow">if</span> (node_tags[n].size()&gt;=10) ++tag_10;</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;        <span class="keywordflow">if</span> (node_tags[n].size()&gt;=50) ++tag_50;</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;        <span class="keywordflow">if</span> (node_tags[n].size()&gt;=100) ++tag_100;</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;        <span class="keywordflow">if</span> (node_tags[n].size()&gt;=1000) ++tag_1000;</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    }</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    sglib::OutputLog()&lt;&lt;selected_nodes.size()&lt;&lt;<span class="stringliteral">&quot; selected totalling &quot;</span>&lt;&lt;total_bp&lt;&lt;<span class="stringliteral">&quot;bp &quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;    sglib::OutputLog()&lt;&lt;tag_10&lt;&lt;<span class="stringliteral">&quot; selected_nodes have 10+ tags&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;    sglib::OutputLog()&lt;&lt;tag_50&lt;&lt;<span class="stringliteral">&quot; selected_nodes have 50+ tags&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;    sglib::OutputLog()&lt;&lt;tag_100&lt;&lt;<span class="stringliteral">&quot; selected_nodes have 100+ tags&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;    sglib::OutputLog()&lt;&lt;tag_1000&lt;&lt;<span class="stringliteral">&quot; selected_nodes have 1000+ tags&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;Computing shared tags&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;<span class="preprocessor">#pragma omp parallel for shared(neighbours) schedule(static,50)</span></div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;<span class="preprocessor"></span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i1=0; i1&lt;selected_nodes.size(); ++i1){</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;        <span class="keyword">auto</span> n1=selected_nodes[i1];</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i2=i1+1;i2&lt;selected_nodes.size();i2++){</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;            <span class="keyword">auto</span> n2=selected_nodes[i2];</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;            uint32_t shared=intersection_size(node_tags[n1],node_tags[n2]);</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;            <span class="keywordflow">if</span> (shared&gt;=10) {</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;<span class="preprocessor">#pragma omp critical</span></div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;<span class="preprocessor"></span>                {</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                    <span class="keywordflow">if</span> (shared&gt;40) tsg.add_link(general_to_tag[n1],general_to_tag[n2],0);</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;                    neighbours[n1].emplace_back(n2,shared);</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;                    neighbours[n2].emplace_back(n1,shared);</div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;                }</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;            }</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;        }</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;    }</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;    tsg.write_to_gfa(<span class="stringliteral">&quot;tag_neighbours_nodir.gfa&quot;</span>);</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;Sorting shared tags&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;    uint64_t with_neighbours=0;</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;nn:neighbours){</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;        <span class="keywordflow">if</span> (not nn.empty()) ++with_neighbours;</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;        std::sort(nn.begin(),nn.end(),[]( <span class="keyword">const</span> std::pair&lt;sgNodeID_t,uint32_t&gt; &amp;a,</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;                                          <span class="keyword">const</span> std::pair&lt;sgNodeID_t,uint32_t&gt; &amp;b) { <span class="keywordflow">return</span> a.second&gt;b.second; });</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;    }</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;    sglib::OutputLog()&lt;&lt;with_neighbours&lt;&lt;<span class="stringliteral">&quot; selected_nodes with neighbours&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;    <span class="keywordflow">return</span> neighbours;</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;}</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;</div>
<div class="line"><a name="l00989"></a><span class="lineno"><a class="line" href="class_untangler.html#a23b9f64ad4194c8740333ab7891c043c">  989</a></span>&#160;std::vector&lt;Link&gt;  <a class="code" href="class_untangler.html#a23b9f64ad4194c8740333ab7891c043c">Untangler::find_tag_neighbours_with_imbalance</a>(uint32_t min_size, <span class="keywordtype">float</span> min_ci, <span class="keywordtype">float</span> max_ci, <span class="keywordtype">float</span> end_perc) {</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;    std::vector&lt;LinkedReadMapper&gt;&amp; linked_read_mappers(ws.getLinkedReadMappers());</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;    std::vector&lt;LinkedReadsDatastore&gt;&amp; linked_read_datastores(ws.getLinkedReadDatastores());</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    <span class="comment">//TODO: divide this and make iterative: start by big fish, then add small in-betweens, simplify transitives into subgraphs</span></div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a> tsg;</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;    std::map&lt;sgNodeID_t,sgNodeID_t&gt; general_to_tag,tag_to_general;</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;Selecting selected_nodes...&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t,uint32_t&gt;&gt;&gt; neighbours;</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    std::vector&lt;std::set&lt;bsg10xTag&gt;&gt; node_tags;</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;    neighbours.resize(sg.nodes.size());</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    node_tags.resize(sg.nodes.size());</div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    uint64_t total_bp=0;</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;    <span class="keyword">auto</span> selected_nodes=ws.select_from_all_nodes(min_size,1000000,20,200000, min_ci, max_ci);</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:selected_nodes) {</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;        general_to_tag[n]=tsg.add_node(sg.nodes[n].sequence);</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;        tag_to_general[general_to_tag[n]]=n;</div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;        tag_to_general[-general_to_tag[n]]=-n;</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;        total_bp+=sg.nodes[n].sequence.size();</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:linked_read_mappers[0].get_node_tags(n)) node_tags[n].insert(t);</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;    }</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;    sglib::OutputLog()&lt;&lt;selected_nodes.size()&lt;&lt;<span class="stringliteral">&quot; selected totalling &quot;</span>&lt;&lt;total_bp&lt;&lt;<span class="stringliteral">&quot;bp &quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;Computing shared tags&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;<span class="preprocessor">#pragma omp parallel for shared(tsg) schedule(static,50)</span></div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;<span class="preprocessor"></span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i1=0; i1&lt;selected_nodes.size(); ++i1){</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;        <span class="keyword">auto</span> n1=selected_nodes[i1];</div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i2=i1+1;i2&lt;selected_nodes.size();i2++){</div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;            <span class="keyword">auto</span> n2=selected_nodes[i2];</div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;            uint32_t shared=intersection_size(node_tags[n1],node_tags[n2]);</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;            <span class="keywordflow">if</span> (shared&gt;=40) {</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;<span class="comment">//                std::cout&lt;&lt;&quot;Strong connection between &quot;&lt;&lt;n1&lt;&lt;&quot; and &quot;&lt;&lt;n2&lt;&lt;&quot; for tag imbalance&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;                <span class="comment">//first create the set of real intersecting tags</span></div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;                std::set&lt;bsg10xTag&gt; shared_tags;</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;                std::set_intersection(node_tags[n1].begin(),node_tags[n1].end(),node_tags[n2].begin(),node_tags[n2].end(),std::inserter(shared_tags,shared_tags.end()));</div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;<span class="comment">//                std::cout&lt;&lt;&quot;intersection set has &quot;&lt;&lt;shared_tags.size()&lt;&lt;&quot; elements&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;                uint64_t n1_front_in=0,n1_front_total=0,n1_back_in=0,n1_back_total=0;</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;                uint64_t n2_front_in=0,n2_front_total=0,n2_back_in=0,n2_back_total=0;</div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;                uint64_t n1first30point=sg.nodes[n1].sequence.size()*end_perc;</div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;                uint64_t n1last30point=sg.nodes[n1].sequence.size()*(1-end_perc);</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> rm:linked_read_mappers[0].reads_in_node[n1]){</div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;                    <span class="keywordflow">if</span> (rm.first_pos&lt;n1first30point){</div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;                        ++n1_front_total;</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;                        <span class="keywordflow">if</span> (shared_tags.count(linked_read_datastores[0].get_read_tag(rm.read_id))&gt;0) ++n1_front_in;</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;                    }</div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;                    <span class="keywordflow">if</span> (rm.last_pos&gt;n1last30point){</div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;                        ++n1_back_total;</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;                        <span class="keywordflow">if</span> (shared_tags.count(linked_read_datastores[0].get_read_tag(rm.read_id))&gt;0) ++n1_back_in;</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;                    }</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;                }</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;                <span class="keyword">auto</span> n1f=(100.0*n1_front_in/n1_front_total);</div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;                <span class="keyword">auto</span> n1b=(100.0*n1_back_in/n1_back_total);</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;<span class="comment">//                std::cout&lt;&lt;&quot; Node &quot;&lt;&lt;n1&lt;&lt;&quot; &quot;&lt;&lt;ws.sg.nodes[n1].sequence.size()&lt;&lt;&quot;bp:  front -&gt; &quot;&lt;&lt;n1f&lt;&lt;&quot; (&quot;&lt;&lt;n1_front_in&lt;&lt;&quot;/&quot;&lt;&lt;n1_front_total&lt;&lt;&quot;)&quot;</span></div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;<span class="comment">//                         &lt;&lt;&quot; back -&gt; &quot;&lt;&lt;n1b&lt;&lt;&quot; (&quot;&lt;&lt;n1_back_in&lt;&lt;&quot;/&quot;&lt;&lt;n1_back_total&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;                uint64_t n2first30point=sg.nodes[n2].sequence.size()*end_perc;</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;                uint64_t n2last30point=sg.nodes[n2].sequence.size()*(1-end_perc);</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> rm:linked_read_mappers[0].reads_in_node[n2]){</div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;                    <span class="keywordflow">if</span> (rm.first_pos&lt;n2first30point){</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;                        ++n2_front_total;</div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;                        <span class="keywordflow">if</span> (shared_tags.count(linked_read_datastores[0].get_read_tag(rm.read_id))&gt;0) ++n2_front_in;</div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;                    }</div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;                    <span class="keywordflow">if</span> (rm.last_pos&gt;n2last30point){</div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;                        ++n2_back_total;</div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;                        <span class="keywordflow">if</span> (shared_tags.count(linked_read_datastores[0].get_read_tag(rm.read_id))&gt;0) ++n2_back_in;</div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;                    }</div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;                }</div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;                <span class="keyword">auto</span> n2f=(100.0*n2_front_in/n2_front_total);</div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;                <span class="keyword">auto</span> n2b=(100.0*n2_back_in/n2_back_total);</div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;<span class="comment">//                std::cout&lt;&lt;&quot; Node &quot;&lt;&lt;n2&lt;&lt;&quot; &quot;&lt;&lt;ws.sg.nodes[n2].sequence.size()&lt;&lt;&quot;bp:  front -&gt; &quot;&lt;&lt;n2f&lt;&lt;&quot; (&quot;&lt;&lt;n2_front_in&lt;&lt;&quot;/&quot;&lt;&lt;n2_front_total&lt;&lt;&quot;)&quot;</span></div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;<span class="comment">//                         &lt;&lt;&quot; back -&gt; &quot;&lt;&lt;n2b&lt;&lt;&quot; (&quot;&lt;&lt;n2_back_in&lt;&lt;&quot;/&quot;&lt;&lt;n2_back_total&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;</div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;                <span class="keywordflow">if</span> (fabs(2*(n1f-n1b)/(n1f+n1b))&gt;.1 and fabs(2*(n2f-n2b)/(n2f+n2b))&gt;.1) {</div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;<span class="comment">//                    std::cout&lt;&lt;&quot;Imbalance solved&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;<span class="preprocessor">#pragma omp critical</span></div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;<span class="preprocessor"></span>                    tsg.add_link((n1f &gt; n1b ? general_to_tag[n1] : -general_to_tag[n1]),</div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;                                 (n2f &gt; n2b ? general_to_tag[n2] : -general_to_tag[n2]), 0);</div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;                }</div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;                <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;<span class="comment">//                    std::cout&lt;&lt;&quot;Imbalance unsolved&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;                }</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;<span class="comment">//#pragma omp critical</span></div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;<span class="comment">/*                {</span></div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="comment">                    //if (shared&gt;40) tsg.add_link(general_to_tag[n1],general_to_tag[n2],0);</span></div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;<span class="comment">                    neighbours[n1].emplace_back(n2,shared);</span></div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;<span class="comment">                    neighbours[n2].emplace_back(n1,shared);</span></div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;<span class="comment">                }*/</span></div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;            }</div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;        }</div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;    }</div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;    tsg.write_to_gfa(<span class="stringliteral">&quot;tag_neighbours_imbdir.gfa&quot;</span>);</div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;    <a class="code" href="class_buffered_tag_kmerizer.html">BufferedTagKmerizer</a> btk(linked_read_datastores[0],31,200000,1000);</div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;    uint64_t perf_ts=0;</div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n=1;n&lt;tsg.nodes.size();++n){</div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;        <span class="keyword">auto</span> b=n;</div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;        <span class="keyword">auto</span> bfw=tsg.get_fw_links(b);</div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;        <span class="keyword">auto</span> bbw=tsg.get_bw_links(b);</div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;        <span class="keywordflow">if</span> (bbw.size()!=1 or bfw.size()!=1) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;        <span class="keyword">auto</span> a=-bbw[0].dest;</div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;        <span class="keyword">auto</span> c=bfw[0].dest;</div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;        <span class="keyword">auto</span> afw=tsg.get_fw_links(a);</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;        <span class="keyword">auto</span> cbw=tsg.get_bw_links(c);</div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;        <span class="keywordflow">if</span> (afw.size()!=2 or cbw.size()!=2) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;        <span class="keywordflow">if</span> (afw[0].dest==c or afw[1].dest==c) {</div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Found perfect transtition &quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;            <span class="keyword">auto</span> A = tag_to_general[a];</div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;            <span class="keyword">auto</span> B = tag_to_general[b];</div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;            <span class="keyword">auto</span> C = tag_to_general[c];</div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;On original ids: &quot;</span> &lt;&lt; A &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; B &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; C &lt;&lt; std::endl;</div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;            std::set&lt;bsg10xTag&gt; tags;</div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:linked_read_mappers[0].get_node_tags(A)) tags.insert(t);</div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:linked_read_mappers[0].get_node_tags(B)) tags.insert(t);</div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:linked_read_mappers[0].get_node_tags(C)) tags.insert(t);</div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;            <span class="keyword">auto</span> ab = <a class="code" href="class_untangler.html#af5d8511828f1d9f6c494253df8c67c9b">get_all_tag_covered_paths</a>(A, B, tags, btk);</div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;            <span class="keyword">auto</span> bc = <a class="code" href="class_untangler.html#af5d8511828f1d9f6c494253df8c67c9b">get_all_tag_covered_paths</a>(B, C, tags, btk);</div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;            <span class="keywordflow">if</span> (ab.size() == 1) std::cout &lt;&lt; <span class="stringliteral">&quot;A-&gt;B Solved!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;            <span class="keywordflow">if</span> (bc.size() == 1) std::cout &lt;&lt; <span class="stringliteral">&quot;B-&gt;C Solved!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;            ++perf_ts;</div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;        }</div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;    }</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;    std::cout&lt;&lt;perf_ts&lt;&lt;<span class="stringliteral">&quot; perfect transitions found&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;    <span class="comment">/*sglib::OutputLog()&lt;&lt;&quot;Sorting shared tags&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;<span class="comment">    uint64_t with_neighbours=0;</span></div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;<span class="comment">    for (auto &amp;nn:neighbours){</span></div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="comment">        if (not nn.empty()) ++with_neighbours;</span></div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="comment">        std::sort(nn.begin(),nn.end(),[]( const std::pair&lt;sgNodeID_t,uint32_t&gt; &amp;a,</span></div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="comment">                                          const std::pair&lt;sgNodeID_t,uint32_t&gt; &amp;b) { return a.second&gt;b.second; });</span></div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;<span class="comment">    }</span></div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="comment">    sglib::OutputLog()&lt;&lt;with_neighbours&lt;&lt;&quot; selected_nodes with neighbours&quot;&lt;&lt;std::endl;*/</span></div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;    <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;}</div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;</div>
<div class="line"><a name="l01121"></a><span class="lineno"><a class="line" href="class_untangler.html#a2ab55e3bd04984f756af0f77cc9ac2c3"> 1121</a></span>&#160;uint64_t <a class="code" href="class_untangler.html#a2ab55e3bd04984f756af0f77cc9ac2c3">Untangler::connect_neighbours</a>(uint64_t min_size, <span class="keywordtype">float</span> min_ci, <span class="keywordtype">float</span> max_ci, int64_t max_distance) {</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;    <span class="comment">//first find all nodes&#39; neighbours</span></div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;    <span class="keyword">auto</span> tagneighbours=<a class="code" href="class_untangler.html#afd3182e869342c4d435a46bb62b243cd">find_tag_neighbours</a>(min_size,min_ci,max_ci);</div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;    std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t,int64_t&gt;&gt;&gt; fndist(sg.nodes.size()),bndist(sg.nodes.size());</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;    <a class="code" href="class_tag_walker.html">TagWalker</a> tw(ws,{});</div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n=1;n&lt;sg.nodes.size();++n) {</div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;        <span class="comment">//explore from a node til hitting a neighbour, check if another selected node is on the way</span></div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;        std::set&lt;sgNodeID_t&gt; ntn;</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> nd:tagneighbours[n]) ntn.emplace(nd.first);</div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;        <span class="keywordflow">if</span> (ntn.empty()) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;        fndist[n] = sg.get_distances_to(n, ntn, max_distance);</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;        bndist[n] = sg.get_distances_to(-n, ntn, max_distance);</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;    }</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;</div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;    <span class="comment">//TODO: only fw or bw neighbour, corresponding, good tag intersection</span></div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;<span class="comment">//    std::cout&lt;&lt;&quot;Finding disconnected tips&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;<span class="comment">//    for (auto n=1;n&lt;ws.sg.nodes.size();++n){</span></div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;<span class="comment">//        if (tagneighbours[n].empty()) continue;</span></div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;<span class="comment">//        if (ws.sg.get_fw_links(n).size()==0 or ws.sg.get_bw_links(n).size()==0) {</span></div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;<span class="comment">//            for (auto tn:tagneighbours[n]){</span></div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;<span class="comment">//                if (ws.sg.get_fw_links(tn.first).size()==0 or ws.sg.get_bw_links(tn.first).size()==0) {</span></div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;<span class="comment">//                    std::cout&lt;&lt;&quot;Nodes &quot;&lt;&lt;n&lt;&lt;&quot; and &quot;&lt;&lt;tn.first&lt;&lt;&quot; have disconnected ends and have &quot;&lt;&lt;tn.second&lt;&lt;&quot; shared tags&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;<span class="comment">//                }</span></div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;<span class="comment">//            }</span></div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;<span class="comment">//        }</span></div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;<span class="comment">//    }</span></div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;    <span class="comment">//connect_neighbours_trivial(min_size,min_ci,max_ci,max_distance,tagneighbours,bndist,fndist);</span></div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;    <span class="comment">//bndist.resize(ws.sg.nodes.size());</span></div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    <span class="comment">//fndist.resize(ws.sg.nodes.size());</span></div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;    <span class="comment">//tagneighbours.resize(ws.sg.nodes.size());</span></div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="class_untangler.html#a9d2be737b7d2e7842492785b9abb453a">connect_neighbours_paths_to_same</a>(min_size,min_ci,max_ci,max_distance,tagneighbours,bndist,fndist);</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;    <span class="comment">//std::cout&lt;&lt;&quot;Analysing non-trivial connections&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;    <span class="comment">//std::cout</span></div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;</div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;        <span class="comment">/*//if successfull, create a copy of the skated path and disconnect/connect appropriately</span></div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;<span class="comment">        //TODO: check if a node with different neighbours is here</span></div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;<span class="comment">        auto walkf=tw.walk_between(n,nd[0].first);</span></div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;<span class="comment">        if (not walkf.nodes.empty()) {</span></div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;<span class="comment">            sg.create_path_through(walkf);</span></div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;<span class="comment">        }</span></div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;<span class="comment">        auto nd=ws.sg.get_distances_to(-n,ntn,100000);</span></div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;<span class="comment">        //if successfull, create a copy of the skated path and disconnect/connect appropriately</span></div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;<span class="comment">        //TODO: check if a node with different neighbours is here</span></div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;<span class="comment">        auto walkb=tw.walk_between(n,nd[0].first);</span></div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;<span class="comment">        if (not walkb.nodes.empty()) {</span></div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;<span class="comment">            sg.create_path_through(walkb);</span></div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;<span class="comment">        }*/</span></div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;</div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;</div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;</div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;}</div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;</div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;<span class="keywordtype">void</span> Untangler::connect_neighbours_trivial(uint64_t min_size, <span class="keywordtype">float</span> min_ci, <span class="keywordtype">float</span> max_ci, int64_t max_distance,</div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;                                           <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t,uint32_t&gt;&gt;&gt; &amp;tagneighbours,</div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;                                           <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t,int64_t&gt;&gt;&gt; &amp; bndist,</div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;                                           <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t,int64_t&gt;&gt;&gt; &amp; fndist) {</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Finding trivial connections&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;    std::vector&lt;std::pair&lt;sgNodeID_t, sgNodeID_t&gt;&gt; from_to;</div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n = 1; n &lt; sg.nodes.size(); ++n) {</div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;<span class="comment">//todo: check that the other node actually has THIS node as neighbour, validate TAG distances too</span></div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;        <span class="keywordflow">if</span> (fndist[n].size() == 1 and</div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;            (fndist[n][0].first &lt; 0 ? fndist : bndist)[llabs(fndist[n][0].first)].size() == 1) {</div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;<span class="comment">//std::cout&lt;&lt;&quot;Nodes &quot;&lt;&lt;n&lt;&lt;&quot; and &quot;&lt;&lt;fndist[n][0].first&lt;&lt;&quot; may be trivial neighbours&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;            <span class="keywordflow">if</span> (llabs(fndist[n][0].first) &gt; n) from_to.push_back({n, fndist[n][0].first});</div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;        }</div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;        <span class="keywordflow">if</span> (bndist[n].size() == 1 and</div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;            (bndist[n][0].first &lt; 0 ? fndist : bndist)[llabs(bndist[n][0].first)].size() == 1) {</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;<span class="comment">//std::cout&lt;&lt;&quot;Nodes &quot;&lt;&lt;-n&lt;&lt;&quot; and &quot;&lt;&lt;bndist[n][0].first&lt;&lt;&quot; may be trivial neighbours&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;            <span class="keywordflow">if</span> (llabs(bndist[n][0].first) &gt; n) from_to.push_back({-n, bndist[n][0].first});</div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;        }</div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;<span class="comment">//should we check also that there is only one single connection out and in the nodes?</span></div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;</div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;    }</div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;    std::cout &lt;&lt; from_to.size() &lt;&lt; <span class="stringliteral">&quot; trivial connections to inflate&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;    uint64_t done = 0;</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> ft:from_to) {</div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;<span class="comment">//Create all possible paths between from_to (sg function):</span></div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;        <span class="keyword">auto</span> allpaths = sg.find_all_paths_between(ft.first, ft.second, 50000);</div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;<span class="comment">//  is there only one? does it contain no selected node? other conditions? Optional: check the path is covered by kmers from tags on both ends of it.</span></div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;        <span class="keywordflow">if</span> (allpaths.size() != 1) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;n: allpaths[0].getNodes()) <span class="keywordflow">if</span> (not tagneighbours[llabs(n)].empty()) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;        <span class="keywordflow">if</span> (allpaths[0].getNodes().empty()) <span class="keywordflow">continue</span>; <span class="comment">//XXX:these should actually be connected directly?</span></div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;<span class="comment">//  create a single node with the sequence of the path, migrate connections from the nodes (sg function)</span></div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;        <span class="keyword">auto</span> new_node = sg.add_node(<a class="code" href="class_node.html">Node</a>(allpaths[0].get_sequence()));</div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;        <span class="keyword">auto</span> old_fw = sg.get_fw_links(ft.first);</div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;l:old_fw) {</div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;            <span class="keywordflow">if</span> (l.dest == allpaths[0].getNodes().front()) sg.add_link(-ft.first, new_node, l.dist);</div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;            sg.remove_link(l.source, l.dest);</div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;        }</div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;        <span class="keyword">auto</span> old_bw = sg.get_bw_links(ft.second);</div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;l:old_bw) {</div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;            <span class="keywordflow">if</span> (l.dest == -allpaths[0].getNodes().back()) sg.add_link(ft.second, -new_node, l.dist);</div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;            sg.remove_link(l.source, l.dest);</div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;        }</div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;<span class="comment">//std::cout&lt;&lt;&quot;Replaced connection between &quot;&lt;&lt;ft.first&lt;&lt;&quot; and &quot;&lt;&lt;ft.second&lt;&lt;&quot; through nodes &quot;;</span></div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;<span class="comment">//for (auto &amp;n:allpaths[0].nodes) std::cout&lt;&lt;n&lt;&lt;&quot; &quot;;</span></div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;<span class="comment">//std::cout&lt;&lt;&quot; by a single node &quot;&lt;&lt;new_node&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;        ++done;</div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;</div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;</div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;    }</div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;    std::cout &lt;&lt; done &lt;&lt; <span class="stringliteral">&quot; connections inflated&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;}</div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;</div>
<div class="line"><a name="l01228"></a><span class="lineno"><a class="line" href="class_untangler.html#a9d2be737b7d2e7842492785b9abb453a"> 1228</a></span>&#160;uint64_t <a class="code" href="class_untangler.html#a9d2be737b7d2e7842492785b9abb453a">Untangler::connect_neighbours_paths_to_same</a>(uint64_t min_size, <span class="keywordtype">float</span> min_ci, <span class="keywordtype">float</span> max_ci, int64_t max_distance,</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;                                           <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t,uint32_t&gt;&gt;&gt; &amp;tagneighbours,</div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;                                           <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t,int64_t&gt;&gt;&gt; &amp; bndist,</div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;                                           <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t,int64_t&gt;&gt;&gt; &amp; fndist) {</div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;    std::vector&lt;LinkedReadsDatastore&gt;&amp; linked_read_datastores(ws.getLinkedReadDatastores());</div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;    std::vector&lt;LinkedReadMapper&gt;&amp; linked_read_mappers(ws.getLinkedReadMappers());</div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Finding multi-path connections to same neighbour&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;    std::vector&lt;std::pair&lt;sgNodeID_t, sgNodeID_t&gt;&gt; from_to;</div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;    std::vector&lt;sgNodeID_t&gt; single_fw(sg.nodes.size(),0),single_bw(sg.nodes.size(),0);</div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;    <span class="comment">//first mark outputs going into a single neighbour</span></div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n = 1; n &lt; sg.nodes.size(); ++n) {</div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;        <span class="keywordflow">if</span> (fndist[n].size()&gt;=1) {</div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;            <span class="keyword">auto</span> fdest = fndist[n][0].first;</div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;            <span class="keywordtype">bool</span> fok = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> fd:fndist[n]) <span class="keywordflow">if</span> (fdest != fd.first) fok = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;            <span class="keywordflow">if</span> (fok) single_fw[n] = fdest;</div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;        }</div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;        <span class="keywordflow">if</span> (bndist[n].size()&gt;=1) {</div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;            <span class="keyword">auto</span> bdest = bndist[n][0].first;</div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;            <span class="keywordtype">bool</span> bok = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> bd:bndist[n]) <span class="keywordflow">if</span> (bdest != bd.first) bok = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;            <span class="keywordflow">if</span> (bok) single_bw[n] = bdest;</div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;        }</div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;    }</div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;    <span class="comment">//now look for happy matches where both have a single connection and it is the same one!</span></div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n = 1; n &lt; sg.nodes.size(); ++n) {</div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;        <span class="keywordflow">if</span> (single_fw[n]&gt;0 and single_fw[n]&lt;n and single_bw[single_fw[n]]==-n) from_to.push_back({n,single_fw[n]});</div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;        <span class="keywordflow">if</span> (single_fw[n]&lt;0 and -single_fw[n]&lt;n and single_fw[-single_fw[n]]==-n) from_to.push_back({n,single_fw[n]});</div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;        <span class="keywordflow">if</span> (single_bw[n]&gt;0 and single_bw[n]&lt;n and single_bw[single_bw[n]]==n) from_to.push_back({-n,single_bw[n]});</div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;        <span class="comment">//std::cout&lt;&lt;&quot;.&quot;&lt;&lt;std::flush;</span></div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;        <span class="keywordflow">if</span> (single_bw[n]&lt;0 and -single_bw[n]&lt;n and single_fw[-single_bw[n]]==n) from_to.push_back({-n,single_bw[n]});</div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;        <span class="comment">//std::cout&lt;&lt;&quot;.&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;    }</div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;    std::cout &lt;&lt; from_to.size() &lt;&lt; <span class="stringliteral">&quot; multi-path connections to same neighbour to inflate&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;</div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;    uint64_t done = 0;</div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;    std::vector&lt;std::pair&lt;std::pair&lt;sgNodeID_t,sgNodeID_t&gt;,<a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a>&gt;&gt; final_sols;</div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;<span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;<span class="preprocessor"></span>    {</div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;        <a class="code" href="class_buffered_tag_kmerizer.html">BufferedTagKmerizer</a> btk(linked_read_datastores[0],31,200000,1000);</div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;<span class="preprocessor">#pragma omp for schedule(dynamic,10)</span></div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;<span class="preprocessor"></span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> idx = 0; idx &lt; from_to.size(); ++idx) {</div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;            <span class="keyword">auto</span> &amp;ft = from_to[idx];</div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;<span class="comment">//Create all possible paths between from_to (sg function):</span></div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;            <span class="keyword">auto</span> allpaths = sg.find_all_paths_between(ft.first, ft.second, max_distance);</div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;</div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;            <span class="keywordtype">bool</span> complex = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:allpaths) {</div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;n: p.getNodes()) {</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;                    <span class="keywordflow">if</span> (not tagneighbours[llabs(n)].empty()) {</div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;                        complex = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;                        <span class="comment">//std::cout&lt;&lt;&quot;A path node has other neighbours!&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;                    }</div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;                }</div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;                <span class="keywordflow">if</span> (p.getNodes().empty()) {</div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;                    complex = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;                    <span class="comment">//std::cout&lt;&lt;&quot;Path is empty!&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;                }</div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;            }</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;            <span class="keywordflow">if</span> (complex or allpaths.empty()) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;Evaluating between &quot;</span> &lt;&lt; allpaths.size() &lt;&lt; <span class="stringliteral">&quot; different paths to join &quot;</span> &lt;&lt; ft.first &lt;&lt; <span class="stringliteral">&quot; and &quot;</span></div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;                      &lt;&lt; ft.second &lt;&lt; std::endl;</div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;            <span class="keyword">auto</span> ntags = linked_read_mappers[0].get_node_tags(ft.first);</div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> t:linked_read_mappers[0].get_node_tags(ft.second)) ntags.insert(t);</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;            <span class="keyword">auto</span> neightagkmers = btk.get_tags_kmers(6, ntags);</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;            std::vector&lt;SequenceGraphPath&gt; sol;</div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:allpaths) {</div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;                <span class="keyword">auto</span> pseq = p.get_sequence();</div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;                <span class="comment">//TODO: this can be doen not with a factory but with a class that already counts how many are in the set</span></div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;                <a class="code" href="class_string_k_mer_factory.html">StringKMerFactory</a> skf(pseq, 31);</div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;                std::vector&lt;uint64_t&gt; seqkmers;</div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;                skf.<a class="code" href="class_string_k_mer_factory.html#aff34d2ccaa9d9ddda612f760cb470979">create_kmers</a>(seqkmers);</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;                uint64_t covered = 0, uncovered = 0;</div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> x:seqkmers) {</div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;                    <span class="keywordflow">if</span> (neightagkmers.count(x) &gt; 0) ++covered;</div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;                    <span class="keywordflow">else</span> ++uncovered;</div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;                }</div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;  path evaluation: &quot;</span> &lt;&lt; covered &lt;&lt; <span class="stringliteral">&quot; covered, &quot;</span> &lt;&lt; uncovered &lt;&lt; <span class="stringliteral">&quot; uncovered&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;                <span class="keywordflow">if</span> (uncovered == 0) sol.push_back(p);</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;            }</div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;            <span class="keywordflow">if</span> (sol.size() == 1) {</div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;                ++done;</div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;JOIN SOLVED!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;<span class="preprocessor">#pragma omp critical</span></div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;<span class="preprocessor"></span>                final_sols.emplace_back(ft, sol[0]);</div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;            }</div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;</div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;</div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;        }</div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;    }</div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;    std::cout &lt;&lt; done &lt;&lt; <span class="stringliteral">&quot; joins solved (connections to inflate)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;sol:final_sols){</div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;        dettach_path_as_new_node(sol.first.first,sol.first.second,sol.second);</div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;    }</div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;    <span class="keywordflow">return</span> final_sols.size();</div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;}</div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;</div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;<span class="keywordtype">void</span> Untangler::dettach_path_as_new_node(sgNodeID_t from, sgNodeID_t to, <a class="code" href="class_sequence_graph_path.html">SequenceGraphPath</a> path) {</div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;    <span class="keyword">auto</span> new_node = sg.<a class="code" href="class_sequence_graph.html#a6e6d7862335a9d36a0002711b5a95db4">add_node</a>(<a class="code" href="class_node.html">Node</a>(path.get_sequence()));</div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;    <span class="keyword">auto</span> old_fw = sg.get_fw_links(from);</div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;l:old_fw) {</div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;        <span class="keywordflow">if</span> (l.dest == path.getNodes().front()) sg.add_link(-from, new_node, l.dist);</div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;        sg.remove_link(l.source, l.dest);</div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;    }</div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;    <span class="keyword">auto</span> old_bw = sg.get_bw_links(to);</div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;l:old_bw) {</div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;        <span class="keywordflow">if</span> (l.dest == -path.getNodes().back()) sg.add_link(to, -new_node, l.dist);</div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;        sg.remove_link(l.source, l.dest);</div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;    }</div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;}</div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;</div>
<div class="line"><a name="l01341"></a><span class="lineno"><a class="line" href="class_untangler.html#af5d8511828f1d9f6c494253df8c67c9b"> 1341</a></span>&#160;std::vector&lt;SequenceGraphPath&gt; <a class="code" href="class_untangler.html#af5d8511828f1d9f6c494253df8c67c9b">Untangler::get_all_tag_covered_paths</a>(sgNodeID_t from, sgNodeID_t to,</div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;                                                                    std::set&lt;bsg10xTag&gt; &amp;tags,</div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;                                                                    <a class="code" href="class_buffered_tag_kmerizer.html">BufferedTagKmerizer</a> &amp;btk) {</div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;</div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;    int64_t max_distance=50000;</div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;    <span class="keyword">auto</span> allpaths = sg.<a class="code" href="class_sequence_graph.html#a957062feffff6dcc5efdd252069178ad">find_all_paths_between</a>(from, to, max_distance);</div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;</div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;</div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;    <span class="keywordflow">if</span> (allpaths.empty()) <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Evaluating between &quot;</span> &lt;&lt; allpaths.size() &lt;&lt; <span class="stringliteral">&quot; different paths to join &quot;</span> &lt;&lt; from &lt;&lt; <span class="stringliteral">&quot; and &quot;</span></div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;              &lt;&lt; to &lt;&lt; std::endl;</div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;    <span class="keyword">auto</span> neightagkmers = btk.get_tags_kmers(6, tags);</div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;    std::vector&lt;SequenceGraphPath&gt; sol;</div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> p:allpaths) {</div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;        <span class="keyword">auto</span> pseq = p.get_sequence();</div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;        <span class="comment">//TODO: this can be doen not with a factory but with a class that already counts how many are in the set</span></div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;        <a class="code" href="class_string_k_mer_factory.html">StringKMerFactory</a> skf(pseq, 31);</div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;        std::vector&lt;uint64_t&gt; seqkmers;</div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;        skf.<a class="code" href="class_string_k_mer_factory.html#aff34d2ccaa9d9ddda612f760cb470979">create_kmers</a>(seqkmers);</div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;        uint64_t covered = 0, uncovered = 0;</div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> x:seqkmers) {</div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;            <span class="keywordflow">if</span> (neightagkmers.count(x) &gt; 0) ++covered;</div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;            <span class="keywordflow">else</span> ++uncovered;</div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;        }</div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;  path evaluation: &quot;</span> &lt;&lt; covered &lt;&lt; <span class="stringliteral">&quot; covered, &quot;</span> &lt;&lt; uncovered &lt;&lt; <span class="stringliteral">&quot; uncovered&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;        <span class="keywordflow">if</span> (uncovered == 0) sol.push_back(p);</div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;    }</div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;    <span class="keywordflow">return</span> sol;</div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;}</div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;</div>
<div class="line"><a name="l01380"></a><span class="lineno"><a class="line" href="class_untangler.html#a8c431d969f914dce5b034339cc3d86c6"> 1380</a></span>&#160;std::pair&lt;float,float&gt; <a class="code" href="class_untangler.html#a8c431d969f914dce5b034339cc3d86c6">Untangler::tag_read_percentage_at_ends</a>(sgNodeID_t node, std::set&lt;bsg10xTag&gt; tags, <span class="keywordtype">float</span> end_perc,</div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;                                                              uint32_t end_size) {</div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;    std::vector&lt;LinkedReadMapper&gt;&amp; linked_read_mappers(ws.getLinkedReadMappers());</div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;    std::vector&lt;LinkedReadsDatastore&gt;&amp; linked_read_datastores(ws.getLinkedReadDatastores());</div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;    <span class="keyword">auto</span> n1=llabs(node);</div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;    <span class="keywordflow">if</span> (end_size==0) end_size=sg.nodes[n1].sequence.size()*end_perc;</div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;    <span class="keyword">auto</span> first_chunk=end_size;</div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;    <span class="keyword">auto</span> last_chunk=sg.nodes[n1].sequence.size()-end_size;</div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;    uint64_t n1_front_in=0,n1_front_total=0,n1_back_in=0,n1_back_total=0;</div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> rm:linked_read_mappers[0].reads_in_node[n1]){</div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;        <span class="keywordflow">if</span> (rm.first_pos&lt;first_chunk){</div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;            ++n1_front_total;</div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;            <span class="keywordflow">if</span> (tags.count(linked_read_datastores[0].get_read_tag(rm.read_id))&gt;0) ++n1_front_in;</div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;        }</div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;        <span class="keywordflow">if</span> (rm.last_pos&gt;last_chunk){</div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;            ++n1_back_total;</div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;            <span class="keywordflow">if</span> (tags.count(linked_read_datastores[0].get_read_tag(rm.read_id))&gt;0) ++n1_back_in;</div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;        }</div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;    }</div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;    <span class="keyword">auto</span> n1f=(100.0*n1_front_in/n1_front_total);</div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;    <span class="keyword">auto</span> n1b=(100.0*n1_back_in/n1_back_total);</div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;    <span class="keywordflow">return</span> {n1f,n1b};</div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;}</div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;</div>
<div class="line"><a name="l01415"></a><span class="lineno"><a class="line" href="class_untangler.html#ade6443c350c3c49d99b9bf56c76aebd2"> 1415</a></span>&#160;std::vector&lt;Backbone&gt; <a class="code" href="class_untangler.html#ade6443c350c3c49d99b9bf56c76aebd2">Untangler::create_backbones</a>(uint64_t min_size, <span class="keywordtype">float</span> min_ci, <span class="keywordtype">float</span> max_ci, <span class="keywordtype">float</span> end_perc, <span class="keywordtype">int</span> min_shared_tags) {</div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;    std::vector&lt;LinkedReadMapper&gt;&amp; linked_read_mappers(ws.getLinkedReadMappers());</div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;</div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;    std::vector&lt;Backbone&gt; backbones;</div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;    <span class="keyword">auto</span> selected_nodes=ws.select_from_all_nodes(min_size,1000000,20,200000, min_ci, max_ci);</div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;    std::vector&lt;std::pair&lt;sgNodeID_t , sgNodeID_t&gt;&gt; linked_nodes;</div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;    linked_nodes.reserve(10*selected_nodes.size());</div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;    std::vector&lt;std::set&lt;bsg10xTag &gt;&gt; selected_nodes_tags;</div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;    selected_nodes_tags.reserve(selected_nodes.size());</div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;Computing directional connections among &quot;</span>&lt;&lt;selected_nodes.size()&lt;&lt;<span class="stringliteral">&quot; nodes&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:selected_nodes) selected_nodes_tags.push_back(linked_read_mappers[0].get_node_tags(n));</div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;<span class="preprocessor">#pragma omp parallel for schedule (static,50)</span></div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;<span class="preprocessor"></span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i1=0;i1&lt;selected_nodes.size();++i1){</div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;        <span class="keyword">auto</span> n1=selected_nodes[i1];</div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i2=i1+1;i2&lt;selected_nodes.size();++i2){</div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;            <span class="keyword">auto</span> n2=selected_nodes[i2];</div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;            std::set&lt;bsg10xTag&gt; shared_tags;</div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;            std::set_intersection(selected_nodes_tags[i1].begin(),selected_nodes_tags[i1].end(),</div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;                                  selected_nodes_tags[i2].begin(),selected_nodes_tags[i2].end(),</div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;                                  std::inserter(shared_tags,shared_tags.end()));</div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;            <span class="keywordflow">if</span> (shared_tags.size()&gt;min_shared_tags) {</div>
<div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;                <span class="keyword">auto</span> n1fb=<a class="code" href="class_untangler.html#a8c431d969f914dce5b034339cc3d86c6">tag_read_percentage_at_ends</a>(n1,shared_tags, end_perc);</div>
<div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;                <span class="keyword">auto</span> n1f=n1fb.first; <span class="keyword">auto</span> n1b=n1fb.second;</div>
<div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;                <span class="keyword">auto</span> n2fb=<a class="code" href="class_untangler.html#a8c431d969f914dce5b034339cc3d86c6">tag_read_percentage_at_ends</a>(n2,shared_tags, end_perc);</div>
<div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;                <span class="keyword">auto</span> n2f=n2fb.first; <span class="keyword">auto</span> n2b=n2fb.second;</div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;</div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;                <span class="keywordflow">if</span> (fabs(2 * (n1f - n1b) / (n1f + n1b)) &gt; .1 and fabs(2 * (n2f - n2b) / (n2f + n2b)) &gt; .1) {</div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;                    <span class="comment">//std::cout&lt;&lt;&quot;Imbalance solved with &quot;&lt;&lt;shared_tags.size()&lt;&lt;&quot; tags &quot;&lt;&lt;n1&lt;&lt; &quot;( &quot;&lt;&lt;n1f&lt;&lt;&quot;, &quot;&lt;&lt;n1b&lt;&lt;&quot; ) &quot;&lt;&lt;n2&lt;&lt; &quot;( &quot;&lt;&lt;n2f&lt;&lt;&quot;, &quot;&lt;&lt;n2b&lt;&lt;&quot; )&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;<span class="preprocessor">#pragma omp critical</span></div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;<span class="preprocessor"></span>                    {</div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;                        linked_nodes.emplace_back((n1f &gt; n1b ? -i1 : i1), (n2f &gt; n2b ? -i2 : i2));</div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;                    }</div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;</div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;                }</div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;            }</div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;</div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;        }</div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;    }</div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;Total connections detected: &quot;</span>&lt;&lt;linked_nodes.size()&lt;&lt;std::endl;</div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;</div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;    <span class="comment">//transform links into fw and bw connections (unelegant!)</span></div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;    std::vector&lt;std::vector&lt;sgNodeID_t&gt;&gt; fw_neighbours(selected_nodes.size());</div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;    std::vector&lt;std::vector&lt;sgNodeID_t&gt;&gt; bw_neighbours(selected_nodes.size());</div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> l:linked_nodes) {</div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;        <span class="keywordflow">if</span> (l.first&gt;0) bw_neighbours[l.first].push_back(l.second);</div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;        <span class="keywordflow">else</span> fw_neighbours[-l.first].push_back(l.second);</div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;        <span class="keywordflow">if</span> (l.second&gt;0) bw_neighbours[l.second].push_back(l.first);</div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;        <span class="keywordflow">else</span> fw_neighbours[-l.second].push_back(l.first);</div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;    }</div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;</div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;    std::ofstream of_node_connections(<span class="stringliteral">&quot;backbone_node_connections.csv&quot;</span>), of_links(<span class="stringliteral">&quot;backbone_links.csv&quot;</span>);</div>
<div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> l:linked_nodes) of_links&lt;&lt;(l.first&gt;0 ? selected_nodes[l.first]:-selected_nodes[-l.first])&lt;&lt;<span class="stringliteral">&quot;, &quot;</span></div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;                                      &lt;&lt;(l.second&gt;0 ? selected_nodes[l.second]:-selected_nodes[-l.second])&lt;&lt;std::endl;</div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;    <span class="comment">// check nodes with only one connection</span></div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;    uint64_t none=0, one_side=0, one_in_one_out=0, multiple=0, two=0;</div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i1=0;i1&lt;selected_nodes.size();++i1) {</div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;        <span class="keyword">auto</span> n1 = selected_nodes[i1];</div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;        <span class="keywordflow">if</span> (fw_neighbours[i1].size()==0 and bw_neighbours[i1].size()==0) ++none;</div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fw_neighbours[i1].size()==0 or bw_neighbours[i1].size()==0) ++one_side;</div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fw_neighbours[i1].size()==1 and bw_neighbours[i1].size()==1) ++one_in_one_out;</div>
<div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fw_neighbours[i1].size()==2 or bw_neighbours[i1].size()==2) ++two;</div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;        <span class="keywordflow">else</span> ++multiple;</div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;</div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;        of_node_connections&lt;&lt;n1;</div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i2:bw_neighbours[i1]) of_node_connections&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;(i2&gt;0 ? selected_nodes[i2]:-selected_nodes[-i2]);</div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;        of_node_connections&lt;&lt;std::endl;</div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;        of_node_connections&lt;&lt;-n1;</div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i2:fw_neighbours[i1]) of_node_connections&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;(i2&gt;0 ? selected_nodes[i2]:-selected_nodes[-i2]);</div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;        of_node_connections&lt;&lt;std::endl;</div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;    }</div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;    std::cout&lt;&lt;none&lt;&lt;<span class="stringliteral">&quot; nodes no in or out connections&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;    std::cout&lt;&lt;one_side&lt;&lt;<span class="stringliteral">&quot; nodes have one-side-only connections&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;    std::cout&lt;&lt;one_in_one_out&lt;&lt;<span class="stringliteral">&quot; nodes have 1 in and 1 out connections&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;    std::cout&lt;&lt;two&lt;&lt;<span class="stringliteral">&quot; nodes have 2 connections on at least one side&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;    std::cout&lt;&lt;multiple&lt;&lt;<span class="stringliteral">&quot; nodes have multiple connections, with at least 1 per side&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;</div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;</div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;    <span class="comment">//check and remove simple linear transitive connections</span></div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;</div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;    <span class="comment">//check nodes with multiple incoherent transtitions (repeats)</span></div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;<span class="comment">    std::vector&lt;bool&gt; used(selected_nodes.size(),false);</span></div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;<span class="comment">    for (auto i1=0;i1&lt;selected_nodes.size();++i1) {</span></div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;<span class="comment">        if (selected_nodes[i1]) continue;</span></div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;<span class="comment">        auto n1 = selected_nodes[i1];</span></div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;<span class="comment">        backbones.emplace_back(ws,*this);</span></div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;<span class="comment">        used[n1]=true;</span></div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;<span class="comment">        std::vector&lt;sgNodeID_t&gt; last_added={i1};</span></div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;<span class="comment">        backbones.back().nodes.push_back(n1);</span></div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;<span class="comment">        while (not last_added.empty()){</span></div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;<span class="comment">            std::vector&lt;sgNodeID_t&gt; new_last_added;</span></div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;<span class="comment">            for (auto x:last_added){</span></div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;<span class="comment">                for (auto y:node_neighbours[x]){</span></div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;<span class="comment">                    if (not used[y]){</span></div>
<div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;<span class="comment">                        used[y]=true;</span></div>
<div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;<span class="comment">                        backbones.back().nodes.push_back(selected_nodes[y]);</span></div>
<div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;<span class="comment">                        new_last_added.push_back(y);</span></div>
<div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;<span class="comment">                    }</span></div>
<div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;<span class="comment">                }</span></div>
<div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;<span class="comment">            }</span></div>
<div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;<span class="comment">            last_added=new_last_added;</span></div>
<div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;<span class="comment">        }</span></div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;<span class="comment">        std::cout&lt;&lt;&quot;new backbone: &quot;;</span></div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;<span class="comment">        for (auto n:backbones.back().nodes) std::cout&lt;&lt;&quot;seq&quot;&lt;&lt;n&lt;&lt;&quot;, &quot;;</span></div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;<span class="comment">        std::cout&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;<span class="comment">    }</span></div>
<div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;<span class="comment">*/</span></div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;    <span class="keywordflow">return</span> backbones;</div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;</div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;}</div>
<div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;</div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;<span class="keywordtype">void</span> Untangler::unroll_simple_loops() {</div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;    <a class="code" href="class_kmer_compression_index.html">KmerCompressionIndex</a>&amp; kci(ws.getKCI());</div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;</div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;    std::vector&lt;bool&gt; used(sg.nodes.size(),<span class="keyword">false</span>);</div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=1;i&lt;sg.nodes.size();++i){</div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;        <span class="keywordflow">if</span> (sg.nodes[i].status==sgNodeDeleted) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;        <span class="keywordflow">if</span> (used[i]) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;        <span class="keyword">auto</span> fwl=sg.get_fw_links(i);</div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;        <span class="keyword">auto</span> bwl=sg.get_bw_links(i);</div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> f:fwl) {</div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> b:bwl) {</div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;                <span class="keywordflow">if</span> (f.dest == -b.dest) {</div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;                    used[i]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;                    used[llabs(f.dest)]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;                    <span class="comment">//std::cout&lt;&lt; &quot;simple loop detected between &quot;</span></div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;                    <span class="comment">//         &lt;&lt;i&lt;&lt; &quot; (&quot;&lt;&lt;ws.sg.nodes[i].sequence.size()&lt;&lt;&quot;bp, kci=&quot;&lt;&lt;ws.kci.compute_compression_for_node(i,1)&lt;&lt;&quot;) and &quot;</span></div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;                    <span class="comment">//         &lt;&lt; f.dest &lt;&lt;&quot; (&quot;&lt;&lt;ws.sg.nodes[llabs(f.dest)].sequence.size()&lt;&lt;&quot;bp, kci=&quot;&lt;&lt;ws.kci.compute_compression_for_node(llabs(f.dest),1)&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;                    std::cout&lt;&lt;<span class="stringliteral">&quot;seq&quot;</span>&lt;&lt;i&lt;&lt; <span class="stringliteral">&quot;, &quot;</span>&lt;&lt;sg.nodes[i].sequence.size()&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;kci.compute_compression_for_node(i,1)&lt;&lt;<span class="stringliteral">&quot;, seq&quot;</span></div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;                            &lt;&lt; llabs(f.dest) &lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;sg.nodes[llabs(f.dest)].sequence.size()&lt;&lt;<span class="stringliteral">&quot;, &quot;</span>&lt;&lt;kci.compute_compression_for_node(llabs(f.dest),1)&lt;&lt;std::endl;</div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;                }</div>
<div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;            }</div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;        }</div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;</div>
<div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;    }</div>
<div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;}</div>
<div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;</div>
<div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;<span class="keywordtype">void</span> PairedReadLinker::generate_links_size_ci( uint32_t min_size, <span class="keywordtype">float</span> min_ci, <span class="keywordtype">float</span> max_ci,<span class="keywordtype">int</span> min_reads) {</div>
<div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;    std::vector&lt;bool&gt; to_link(sg.nodes.size());</div>
<div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;n:ws.select_from_all_nodes(min_size,1000000000,0,1000000000,min_ci,max_ci)) to_link[n]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;    generate_links(to_link,min_reads);</div>
<div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;}</div>
<div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;<span class="keywordtype">void</span> PairedReadLinker::generate_links_hspnp(<span class="keywordtype">int</span> min_reads) {</div>
<div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;    std::vector&lt;bool&gt; to_link(sg.nodes.size());</div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;    uint64_t count=0,bp=0;</div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;n:u.get_all_HSPNPs()) {</div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;        to_link[llabs(n.first)]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;        to_link[llabs(n.second)]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;        ++count;</div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;        bp+=sg.nodes[llabs(n.first)].sequence.size()+sg.nodes[llabs(n.second)].sequence.size();</div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;    }</div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;    sglib::OutputLog()&lt;&lt;count&lt;&lt;<span class="stringliteral">&quot; nodes in HSPNP selected for linkage totalling &quot;</span>&lt;&lt;bp&lt;&lt;std::endl;</div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;    generate_links(to_link,min_reads);</div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;}</div>
<div class="line"><a name="l01572"></a><span class="lineno"><a class="line" href="class_paired_read_linker.html#a2d79e91c52a2fc7bc0d2de0a7748eb9e"> 1572</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="class_paired_read_linker.html#a2d79e91c52a2fc7bc0d2de0a7748eb9e">PairedReadLinker::generate_links</a>( <span class="keyword">const</span> std::vector&lt;bool&gt; &amp;to_link,<span class="keywordtype">int</span> min_reads) {</div>
<div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;filling orientation indexes&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;    uint64_t revc=0,dirc=0,false_rev=0,false_dir=0,true_rev=0,true_dir=0;</div>
<div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;    std::vector&lt;std::vector&lt;bool&gt;&gt; orientation;</div>
<div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;pm:ws.getPairedReadMappers()){</div>
<div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;        orientation.emplace_back();</div>
<div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;        orientation.back().resize(pm.read_to_node.size());</div>
<div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n=1;n&lt;sg.nodes.size();++n)</div>
<div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;rm:pm.reads_in_node[n]) {</div>
<div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;            orientation.back()[rm.read_id]=rm.rev;</div>
<div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;            <span class="keywordflow">if</span> (rm.first_pos&lt;rm.last_pos){<span class="keywordflow">if</span> (rm.rev) ++false_rev; <span class="keywordflow">else</span> ++true_rev;};</div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;            <span class="keywordflow">if</span> (rm.first_pos&gt;rm.last_pos ){<span class="keywordflow">if</span> (!rm.rev) ++false_dir; <span class="keywordflow">else</span> ++true_dir;};</div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;            <span class="keywordflow">if</span> (rm.rev) revc++;</div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;            <span class="keywordflow">else</span> dirc++;</div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;        }</div>
<div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;    }</div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;    std::ofstream lof(<span class="stringliteral">&quot;paired_links.txt&quot;</span>);</div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;FW: &quot;</span>&lt;&lt;dirc&lt;&lt;<span class="stringliteral">&quot; ( &quot;</span>&lt;&lt;true_dir&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt; false_dir&lt;&lt;<span class="stringliteral">&quot; )&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;BW: &quot;</span>&lt;&lt;revc&lt;&lt;<span class="stringliteral">&quot; ( &quot;</span>&lt;&lt;true_rev&lt;&lt;<span class="stringliteral">&quot; - &quot;</span>&lt;&lt; false_rev&lt;&lt;<span class="stringliteral">&quot; )&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;    std::map&lt;std::pair&lt;sgNodeID_t, sgNodeID_t&gt;, uint64_t&gt; lv;</div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;collecting link votes across all paired libraries&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;    <span class="comment">//use all libraries collect votes on each link</span></div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;    <span class="keyword">auto</span> rmi=0;</div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;pm:ws.getPairedReadMappers()) {</div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 1; i &lt; pm.read_to_node.size(); i += 2) {</div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;            sgNodeID_t n1 = pm.read_to_node[i];</div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;            sgNodeID_t n2 = pm.read_to_node[i + 1];</div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;            <span class="keywordflow">if</span> (n1 == 0 or n2 == 0 or n1 == n2 or !to_link[n1] or !to_link[n2]) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;            <span class="keywordflow">if</span> (orientation[rmi][i]) n1=-n1;</div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;            <span class="keywordflow">if</span> (orientation[rmi][i+1]) n2=-n2;</div>
<div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;            <span class="keywordflow">if</span> (llabs(n1) &gt; llabs(n2)) std::swap(n1,n2);</div>
<div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;            ++lv[std::make_pair(n1, n2)];</div>
<div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;        }</div>
<div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;        ++rmi;</div>
<div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;    }</div>
<div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;</div>
<div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;adding links with &quot;</span>&lt;&lt;min_reads&lt;&lt;<span class="stringliteral">&quot; votes&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;    <span class="comment">//std::vector&lt;std::vector&lt;std::pair&lt;sgNodeID_t ,uint64_t&gt;&gt;&gt; nodelinks(ws.sg.nodes.size());</span></div>
<div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> l:lv) {</div>
<div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;        <span class="keywordflow">if</span> (l.second&gt;=min_reads){</div>
<div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;            <span class="comment">//todo: size, appropriate linkage handling, etc</span></div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;            <span class="comment">//todo: check alternative signs for same linkage</span></div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;            <span class="keyword">auto</span> s=l.first.first;</div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;            <span class="keyword">auto</span> d=l.first.second;</div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;            <span class="keyword">auto</span> v1=std::make_pair(-s,d);</div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;            <span class="keyword">auto</span> v2=std::make_pair(-s,-d);</div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;            <span class="keyword">auto</span> v3=std::make_pair(s,-d);</div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;            <span class="keywordflow">if</span> (lv.count(v1) and lv[v1]&gt;5*l.second) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;            <span class="keywordflow">if</span> (lv.count(v2) and lv[v2]&gt;5*l.second) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;            <span class="keywordflow">if</span> (lv.count(v3) and lv[v3]&gt;5*l.second) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;            add_link(l.first.first,l.first.second,0);</div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;            <span class="comment">//lof&lt;&lt;l.first.first&lt;&lt;&quot; &quot;&lt;&lt;l.first.second&lt;&lt;&quot; &quot;&lt;&lt;l.second&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;        }</div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;    }</div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;    sglib::OutputLog()&lt;&lt;<span class="stringliteral">&quot;dumping links&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n=1;n&lt;sg.nodes.size();++n) {</div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;        <span class="keyword">auto</span> fwl=get_fw_links(n);</div>
<div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;        <span class="keyword">auto</span> bwl=get_bw_links(n);</div>
<div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;        <span class="keywordflow">if</span> (!fwl.empty()) {</div>
<div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;            lof&lt;&lt;n&lt;&lt;<span class="stringliteral">&quot; FW: &quot;</span>;</div>
<div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;l:fwl) lof&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;l.dest;</div>
<div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;            lof&lt;&lt;std::endl&lt;&lt;<span class="stringliteral">&quot;          seq&quot;</span>&lt;&lt;n;</div>
<div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;l:fwl) lof&lt;&lt;<span class="stringliteral">&quot;, seq&quot;</span>&lt;&lt;llabs(l.dest);</div>
<div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;            lof&lt;&lt;std::endl;</div>
<div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;        }</div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;        <span class="keywordflow">if</span> (!bwl.empty()) {</div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;            lof&lt;&lt;n&lt;&lt;<span class="stringliteral">&quot; BW: &quot;</span>;</div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;l:bwl) lof&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;l.dest;</div>
<div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;            lof&lt;&lt;std::endl&lt;&lt;<span class="stringliteral">&quot;          seq&quot;</span>&lt;&lt;n;</div>
<div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;l:bwl) lof&lt;&lt;<span class="stringliteral">&quot;, seq&quot;</span>&lt;&lt;llabs(l.dest);</div>
<div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;            lof&lt;&lt;std::endl;</div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;        }</div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;    }</div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;    <span class="comment">//TODO: remove printing</span></div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;<span class="comment">//    lof&lt;&lt;n&lt;&lt;&quot;: &quot;;</span></div>
<div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;<span class="comment">//    for (auto l:flv) lof&lt;&lt;&quot; &quot;&lt;&lt;l.first&lt;&lt;&quot;(&quot;&lt;&lt;l.second&lt;&lt;&quot;)&quot;;</span></div>
<div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;<span class="comment">//    lof&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;    <span class="comment">//filter by min reads</span></div>
<div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;    <span class="comment">//infer size?</span></div>
<div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;    <span class="comment">//TODO:hardcoded LMP orientation</span></div>
<div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;</div>
<div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;</div>
<div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;}</div>
<div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;</div>
<div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;<span class="keywordtype">void</span> PairedReadLinker::add_link(sgNodeID_t source, sgNodeID_t dest, int32_t d) {</div>
<div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;    <a class="code" href="class_link.html">Link</a> l(source,dest,d);</div>
<div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;    links[(source &gt; 0 ? source : -source)].emplace_back(l);</div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;    std::swap(l.source,l.dest);</div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;    links[(dest &gt; 0 ? dest : -dest)].emplace_back(l);</div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;}</div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;</div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;<span class="keywordtype">void</span> PairedReadLinker::remove_link(sgNodeID_t source, sgNodeID_t dest) {</div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;    <span class="keyword">auto</span> &amp; slinks = links[(source &gt; 0 ? source : -source)];</div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;    slinks.erase(std::remove(slinks.begin(), slinks.end(), <a class="code" href="class_link.html">Link</a>(source,dest,0)), slinks.end());</div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;    <span class="keyword">auto</span> &amp; dlinks = links[(dest &gt; 0 ? dest : -dest)];</div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;    dlinks.erase(std::remove(dlinks.begin(), dlinks.end(), <a class="code" href="class_link.html">Link</a>(dest,source,0)), dlinks.end());</div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;</div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;}</div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;</div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;std::vector&lt;Link&gt; PairedReadLinker::get_fw_links( sgNodeID_t n){</div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;    std::vector&lt;Link&gt; r;</div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;l:links[(n&gt;0 ? n : -n)]) <span class="keywordflow">if</span> (l.source==-n) r.emplace_back(l);</div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;    <span class="keywordflow">return</span> r;</div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;}</div>
<div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;</div>
<div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;<span class="comment">//returns a list of all fw nodes up to radius jumps away.</span></div>
<div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;std::set&lt;sgNodeID_t&gt; PairedReadLinker::fw_reached_nodes(sgNodeID_t n, <span class="keywordtype">int</span> radius) {</div>
<div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;    std::set&lt;sgNodeID_t&gt; reached,last={n};</div>
<div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=0;i&lt;radius;++i) {</div>
<div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;        std::set&lt;sgNodeID_t&gt; new_last;</div>
<div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> l:last){</div>
<div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> fwl:get_fw_links(l)){</div>
<div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;                new_last.insert(fwl.dest);</div>
<div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;                reached.insert(fwl.dest);</div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;            }</div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;        }</div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;        std::swap(last,new_last);</div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;    }</div>
<div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;    <span class="keywordflow">return</span> reached;</div>
<div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;}</div>
<div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;</div>
<div class="line"><a name="l01694"></a><span class="lineno"><a class="line" href="class_paired_read_linker.html#a882fb2b8454f2a6d63c65e9874126e45"> 1694</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="class_paired_read_linker.html#a882fb2b8454f2a6d63c65e9874126e45">PairedReadLinker::remove_transitive_links</a>(<span class="keywordtype">int</span> radius) {</div>
<div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;removing transitive connections...&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;</div>
<div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;    <span class="comment">//TODO: check mutually transitive connections (A-&gt;B, B-&gt;C, A-&gt;C, C-&gt;B)</span></div>
<div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> fn=1;fn&lt;sg.nodes.size();++fn) {</div>
<div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n:{fn,-fn}) {</div>
<div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;            <span class="comment">//create a list of fw nodes reached through each fw connection in up to radius steps</span></div>
<div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;</div>
<div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;            <span class="keyword">auto</span> fwl = get_fw_links(n);</div>
<div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;            std::vector&lt;sgNodeID_t&gt; neighbours;</div>
<div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;            std::vector&lt;std::set&lt;sgNodeID_t&gt;&gt; reaches;</div>
<div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> fl:fwl){</div>
<div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;                neighbours.push_back(fl.dest);</div>
<div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;                reaches.push_back(fw_reached_nodes(fl.dest,radius));</div>
<div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;            }</div>
<div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;            <span class="keywordflow">if</span> (neighbours.empty()) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;            std::set&lt;sgNodeID_t&gt; indirect;</div>
<div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> bi=0;bi&lt;neighbours.size();++bi){</div>
<div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;                <span class="keyword">auto</span> b=neighbours[bi];</div>
<div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> ci=0;ci&lt;neighbours.size();++ci){</div>
<div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;                    <span class="keywordflow">if</span> (bi==ci) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;                    <span class="keyword">auto</span> c=neighbours[ci];</div>
<div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;                    <span class="comment">//if C is reached through B but B is not through C, then remove connection to C.</span></div>
<div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;                    <span class="keywordflow">if</span> (reaches[bi].count(c)&gt;0 and reaches[ci].count(b)==0){</div>
<div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;                        <span class="comment">//std::cout &lt;&lt; &quot;Transitive connection detected! &quot; &lt;&lt; n &lt;&lt; &quot; -&gt; &quot; &lt;&lt; b &lt;&lt; &quot; -&gt; &quot;</span></div>
<div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;                        <span class="comment">//          &lt;&lt; c &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;                        <span class="comment">//std::cout &lt;&lt; &quot;  seq&quot; &lt;&lt; llabs(n) &lt;&lt; &quot;, seq&quot; &lt;&lt; b &lt;&lt; &quot;, seq&quot; &lt;&lt; llabs(c) &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;                        indirect.insert(c);</div>
<div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;                    }</div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;                }</div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;</div>
<div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;            }</div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;            std::cout&lt;&lt;<span class="stringliteral">&quot;Connections for node &quot;</span> &lt;&lt;labs(n) &lt;&lt; (n&gt;0 ? <span class="stringliteral">&quot; FW&quot;</span>:<span class="stringliteral">&quot; BW&quot;</span>)&lt;&lt;<span class="stringliteral">&quot;:&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> l:neighbours) {</div>
<div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;                std::cout&lt;&lt;l;</div>
<div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;                <span class="keywordflow">if</span> (indirect.count(l)&gt;0) std::cout&lt;&lt;<span class="stringliteral">&quot; indirect&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;                <span class="keywordflow">else</span> std::cout&lt;&lt;<span class="stringliteral">&quot; DIRECT!&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;            }</div>
<div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;        }</div>
<div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;</div>
<div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;    }</div>
<div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;    std::cout&lt;&lt;<span class="stringliteral">&quot;removing transitive connections DONE&quot;</span>&lt;&lt;std::endl;</div>
<div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;}</div>
<div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;</div>
<div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;std::vector&lt;std::vector&lt;sgNodeID_t&gt;&gt; PairedReadLinker::find_local_problems(uint64_t long_node_size) {</div>
<div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;    <a class="code" href="class_sequence_graph.html">SequenceGraph</a>&amp; sg(ws.getGraph());</div>
<div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;    std::vector&lt;std::vector&lt;sgNodeID_t&gt;&gt; local_problem;</div>
<div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;    std::vector&lt;bool&gt; used_fw(sg.nodes.size());</div>
<div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;    std::vector&lt;bool&gt; used_bw(sg.nodes.size());</div>
<div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n=1;n&lt;sg.nodes.size();++n) {</div>
<div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;        <span class="comment">//start from a long node going fw (and later bw)</span></div>
<div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;        <span class="keywordflow">if</span> (sg.nodes[n].sequence.size()&lt;long_node_size) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> sn:{n,-n}) {</div>
<div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;            <span class="keywordflow">if</span> (sn==n and used_fw[n]) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;            <span class="keywordflow">if</span> (sn==-n and used_bw[n]) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;            <span class="comment">//get all bidirectional neighbours from all other nodes, dont go through long nodes (frontiers)</span></div>
<div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;            <span class="comment">//std::cout&lt;&lt;&quot;checking large node &quot;&lt;&lt;n&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;            std::set&lt;sgNodeID_t&gt; internal_nodes;</div>
<div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;            std::set&lt;sgNodeID_t&gt; frontiers={sn};</div>
<div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;            <span class="keywordtype">bool</span> mod=<span class="keyword">true</span>;</div>
<div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;            <span class="keywordflow">while</span> (mod) {</div>
<div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;                <span class="comment">//std::cout&lt;&lt;&quot; new expansion round &quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;                <span class="comment">//std::cout&lt;&lt;&quot;  frontiers: &quot;;</span></div>
<div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;                <span class="comment">//for (auto f:frontiers)std::cout&lt;&lt;&quot; &quot;&lt;&lt;f;</span></div>
<div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;                <span class="comment">//std::cout&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;                <span class="comment">//std::cout&lt;&lt;&quot;  internals: &quot;;</span></div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;                <span class="comment">//for (auto f:internal_nodes)std::cout&lt;&lt;&quot; &quot;&lt;&lt;f;</span></div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;                <span class="comment">//std::cout&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;                mod=<span class="keyword">false</span>;</div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;                <span class="comment">//grab all neighbours of internal nodes and all fw_neighbours of frontiers till no new nodes or too many</span></div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;                <span class="keyword">auto</span> fwn=frontiers;</div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> in:internal_nodes) {</div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;                    fwn.insert(in);</div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;                    fwn.insert(-in);</div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;                }</div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> f:fwn) {</div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;                    <span class="comment">//std::cout&lt;&lt;&quot;  checking fw links of &quot;&lt;&lt;f&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span> fwl:get_fw_links(f)) {</div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;                        <span class="keyword">auto</span> en=fwl.dest;</div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;                        <span class="comment">//std::cout&lt;&lt;&quot;    found connection to &quot;&lt;&lt;en&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;                        <span class="keywordflow">if</span> (sg.nodes[llabs(en)].sequence.size()&lt;long_node_size){</div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;                            <span class="comment">//std::cout&lt;&lt;&quot;     &quot;&lt;&lt;en&lt;&lt;&quot; is short&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;                            <span class="keywordflow">if</span> (internal_nodes.count(en)==0 and internal_nodes.count(-en)==0){</div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;                                mod=<span class="keyword">true</span>;</div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;                                internal_nodes.insert(en);</div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;                                <span class="comment">//std::cout&lt;&lt;&quot;     &quot;&lt;&lt;en&lt;&lt;&quot; added to internal nodes&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;                            }</div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;                        }</div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;                        <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;                            <span class="comment">//std::cout&lt;&lt;&quot;     &quot;&lt;&lt;en&lt;&lt;&quot; is long&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;                            <span class="keywordflow">if</span> (frontiers.count(-en)==0){</div>
<div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;                                mod=<span class="keyword">true</span>;</div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;                                frontiers.insert(-en);</div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;                                <span class="comment">//std::cout&lt;&lt;&quot;     &quot;&lt;&lt;-en&lt;&lt;&quot; added to frontiers&quot;&lt;&lt;std::endl;</span></div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;                            }</div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;                        }</div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;                    }</div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;                }</div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;                <span class="keywordflow">if</span> (frontiers.size()+internal_nodes.size()&gt;100) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;            }</div>
<div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;            <span class="comment">//add result to local_problem</span></div>
<div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;            <span class="keywordflow">if</span> (frontiers.size()+internal_nodes.size()&gt;100) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;            local_problem.push_back({});</div>
<div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> f:frontiers) {</div>
<div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;                local_problem.back().push_back(f);</div>
<div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;                <span class="keywordflow">if</span> (f&gt;0) used_fw[f]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;                <span class="keywordflow">else</span> used_bw[-f]=<span class="keyword">true</span>;</div>
<div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;            }</div>
<div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> f:internal_nodes) local_problem.back().push_back(f);</div>
<div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;        }</div>
<div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;    }</div>
<div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;    <span class="keywordflow">return</span> local_problem;</div>
<div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;}</div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;</div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;std::vector&lt;std::vector&lt;sgNodeID_t&gt;&gt; PairedReadLinker::solve_local_problem(std::vector&lt;sgNodeID_t&gt; connected_nodes) {</div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;    <a class="code" href="class_paired_read_linker.html">PairedReadLinker</a> local_linker(ws, u, *<span class="keyword">this</span>, connected_nodes); <span class="comment">//create a local linker with only the selected node&#39;s connections</span></div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;    local_linker.remove_transitive_links(10);</div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;    <span class="comment">//if (local_linker.is_fully_solved()) return local_linker.get_all_lines();</span></div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;    <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;</div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;}</div>
<div class="ttc" id="class_tag_walker_html"><div class="ttname"><a href="class_tag_walker.html">TagWalker</a></div><div class="ttdef"><b>Definition:</b> <a href="_tag_walker_8hpp_source.html#l00011">TagWalker.hpp:11</a></div></div>
<div class="ttc" id="class_kmer_compression_index_html"><div class="ttname"><a href="class_kmer_compression_index.html">KmerCompressionIndex</a></div><div class="ttdef"><b>Definition:</b> <a href="_kmer_compression_index_8hpp_source.html#l00013">KmerCompressionIndex.hpp:13</a></div></div>
<div class="ttc" id="class_untangler_html_ade6443c350c3c49d99b9bf56c76aebd2"><div class="ttname"><a href="class_untangler.html#ade6443c350c3c49d99b9bf56c76aebd2">Untangler::create_backbones</a></div><div class="ttdeci">std::vector&lt; Backbone &gt; create_backbones(uint64_t min_size, float min_ci, float max_ci, float end_perc, int min_shared_tags)</div><div class="ttdoc">, creates backbones by joining tag-neighbours with tag imbalance. starts by larger nodes ...</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l01415">Untangler.cc:1415</a></div></div>
<div class="ttc" id="class_sequence_graph_html_a6e6d7862335a9d36a0002711b5a95db4"><div class="ttname"><a href="class_sequence_graph.html#a6e6d7862335a9d36a0002711b5a95db4">SequenceGraph::add_node</a></div><div class="ttdeci">sgNodeID_t add_node(Node n)</div><div class="ttdef"><b>Definition:</b> <a href="_sequence_graph_8cc_source.html#l00090">SequenceGraph.cc:90</a></div></div>
<div class="ttc" id="class_buffered_tag_kmerizer_html"><div class="ttname"><a href="class_buffered_tag_kmerizer.html">BufferedTagKmerizer</a></div><div class="ttdoc">kmerises sets of tags, but saves the kmers of individual tags in a buffer to speed-up going through m...</div><div class="ttdef"><b>Definition:</b> <a href="_linked_reads_datastore_8hpp_source.html#l00095">LinkedReadsDatastore.hpp:95</a></div></div>
<div class="ttc" id="class_node_html"><div class="ttname"><a href="class_node.html">Node</a></div><div class="ttdef"><b>Definition:</b> <a href="_generic_types_8hpp_source.html#l00019">GenericTypes.hpp:19</a></div></div>
<div class="ttc" id="class_sequence_graph_html_acd689762f765b68d335cfb841135ca9d"><div class="ttname"><a href="class_sequence_graph.html#acd689762f765b68d335cfb841135ca9d">SequenceGraph::get_fw_links</a></div><div class="ttdeci">std::vector&lt; Link &gt; get_fw_links(sgNodeID_t n) const </div><div class="ttdef"><b>Definition:</b> <a href="_sequence_graph_8cc_source.html#l00131">SequenceGraph.cc:131</a></div></div>
<div class="ttc" id="class_untangler_html_a4a0342058888dad2d987251ddef5d108"><div class="ttname"><a href="class_untangler.html#a4a0342058888dad2d987251ddef5d108">Untangler::analise_paths_through_nodes</a></div><div class="ttdeci">void analise_paths_through_nodes()</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l00431">Untangler.cc:431</a></div></div>
<div class="ttc" id="class_sequence_graph_html_ad7f54e2a8e0a2e74ee21af581ce82c84"><div class="ttname"><a href="class_sequence_graph.html#ad7f54e2a8e0a2e74ee21af581ce82c84">SequenceGraph::join_path</a></div><div class="ttdeci">void join_path(const SequenceGraphPath p, bool consume_nodes=true)</div><div class="ttdef"><b>Definition:</b> <a href="_sequence_graph_8cc_source.html#l00620">SequenceGraph.cc:620</a></div></div>
<div class="ttc" id="class_sequence_graph_html_a8429832b3d8f54b51dc42e444f7e6191"><div class="ttname"><a href="class_sequence_graph.html#a8429832b3d8f54b51dc42e444f7e6191">SequenceGraph::get_bw_links</a></div><div class="ttdeci">std::vector&lt; Link &gt; get_bw_links(sgNodeID_t n) const </div><div class="ttdef"><b>Definition:</b> <a href="_sequence_graph_8cc_source.html#l00137">SequenceGraph.cc:137</a></div></div>
<div class="ttc" id="class_paired_read_linker_html"><div class="ttname"><a href="class_paired_read_linker.html">PairedReadLinker</a></div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8hpp_source.html#l00030">Untangler.hpp:30</a></div></div>
<div class="ttc" id="class_untangler_html_a7e753ec445e5d8e0c99e4fc5d9df2722"><div class="ttname"><a href="class_untangler.html#a7e753ec445e5d8e0c99e4fc5d9df2722">Untangler::make_parallel_paths</a></div><div class="ttdeci">std::vector&lt; SequenceGraphPath &gt; make_parallel_paths(std::vector&lt; SequenceGraphPath &gt;)</div><div class="ttdoc">finds a common source and a common sink, so the paths run parallel through a region ...</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l00369">Untangler.cc:369</a></div></div>
<div class="ttc" id="class_untangler_html_a6b564f0a5d4ed85ef1f2e25bcb894853"><div class="ttname"><a href="class_untangler.html#a6b564f0a5d4ed85ef1f2e25bcb894853">Untangler::all_nodes_consumed</a></div><div class="ttdeci">bool all_nodes_consumed(std::vector&lt; SequenceGraphPath &gt;)</div><div class="ttdoc">validates that a parallel path set uses all nodes between the common source and sink ...</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l00399">Untangler.cc:399</a></div></div>
<div class="ttc" id="class_untangler_html_a85c068929740a3c37eacc1558c0f9e66"><div class="ttname"><a href="class_untangler.html#a85c068929740a3c37eacc1558c0f9e66">Untangler::solve_bubbly_path</a></div><div class="ttdeci">std::pair&lt; SequenceGraphPath, SequenceGraphPath &gt; solve_bubbly_path(const SequenceSubGraph &amp;bp, bool &amp;no_tags)</div><div class="ttdoc">solves a single bubbly path, returns the paths for the 2 new nodes or empty paths if unsolved ...</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l00526">Untangler.cc:526</a></div></div>
<div class="ttc" id="class_sequence_graph_path_html"><div class="ttname"><a href="class_sequence_graph_path.html">SequenceGraphPath</a></div><div class="ttdef"><b>Definition:</b> <a href="_sequence_graph_path_8hpp_source.html#l00012">SequenceGraphPath.hpp:12</a></div></div>
<div class="ttc" id="class_untangler_html_a89273e74b00b26fc5d18c26340fc1225"><div class="ttname"><a href="class_untangler.html#a89273e74b00b26fc5d18c26340fc1225">Untangler::solve_bubbly_path_2</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; SequenceGraphPath, SequenceGraphPath &gt; &gt; solve_bubbly_path_2(const SequenceSubGraph &amp;bp)</div><div class="ttdoc">solves a single bubbly path, returns the paths for the 2 new nodes or empty paths if unsolved can ret...</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l00597">Untangler.cc:597</a></div></div>
<div class="ttc" id="class_sequence_graph_html_a957062feffff6dcc5efdd252069178ad"><div class="ttname"><a href="class_sequence_graph.html#a957062feffff6dcc5efdd252069178ad">SequenceGraph::find_all_paths_between</a></div><div class="ttdeci">std::vector&lt; SequenceGraphPath &gt; find_all_paths_between(sgNodeID_t from, sgNodeID_t to, int64_t max_size, int max_nodes=0)</div><div class="ttdef"><b>Definition:</b> <a href="_sequence_graph_8cc_source.html#l01019">SequenceGraph.cc:1019</a></div></div>
<div class="ttc" id="class_untangler_html_a1f1c5db1f0e2d5f1aacdc040328570d2"><div class="ttname"><a href="class_untangler.html#a1f1c5db1f0e2d5f1aacdc040328570d2">Untangler::get_all_HSPNPs</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; sgNodeID_t, sgNodeID_t &gt; &gt; get_all_HSPNPs()</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l00214">Untangler.cc:214</a></div></div>
<div class="ttc" id="class_sequence_graph_html_a254a345ad26431edfcedb2c7565a6358"><div class="ttname"><a href="class_sequence_graph.html#a254a345ad26431edfcedb2c7565a6358">SequenceGraph::links</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; Link &gt; &gt; links</div><div class="ttdoc">Contains the actual nodes from the graph, nodes are generally accesed using its IDs on to this struct...</div><div class="ttdef"><b>Definition:</b> <a href="graph_2_sequence_graph_8hpp_source.html#l00242">SequenceGraph.hpp:242</a></div></div>
<div class="ttc" id="class_untangler_html_a2ab55e3bd04984f756af0f77cc9ac2c3"><div class="ttname"><a href="class_untangler.html#a2ab55e3bd04984f756af0f77cc9ac2c3">Untangler::connect_neighbours</a></div><div class="ttdeci">uint64_t connect_neighbours(uint64_t min_size, float min_ci, float max_ci, int64_t max_distance)</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l01121">Untangler.cc:1121</a></div></div>
<div class="ttc" id="class_sequence_graph_html"><div class="ttname"><a href="class_sequence_graph.html">SequenceGraph</a></div><div class="ttdoc">Class representing sequence graphs. </div><div class="ttdef"><b>Definition:</b> <a href="graph_2_sequence_graph_8hpp_source.html#l00034">SequenceGraph.hpp:34</a></div></div>
<div class="ttc" id="class_string_k_mer_factory_html_aff34d2ccaa9d9ddda612f760cb470979"><div class="ttname"><a href="class_string_k_mer_factory.html#aff34d2ccaa9d9ddda612f760cb470979">StringKMerFactory::create_kmers</a></div><div class="ttdeci">const bool create_kmers(std::vector&lt; uint64_t &gt; &amp;mers)</div><div class="ttdef"><b>Definition:</b> <a href="_k_mer_factory_8h_source.html#l00069">KMerFactory.h:69</a></div></div>
<div class="ttc" id="class_untangler_html_a8c431d969f914dce5b034339cc3d86c6"><div class="ttname"><a href="class_untangler.html#a8c431d969f914dce5b034339cc3d86c6">Untangler::tag_read_percentage_at_ends</a></div><div class="ttdeci">std::pair&lt; float, float &gt; tag_read_percentage_at_ends(sgNodeID_t node, std::set&lt; bsg10xTag &gt; tags, float end_perc=.1, uint32_t end_size=0)</div><div class="ttdoc">returns the percentage of reads in both ends of node covered by tags in tags </div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l01380">Untangler.cc:1380</a></div></div>
<div class="ttc" id="class_sequence_sub_graph_html"><div class="ttname"><a href="class_sequence_sub_graph.html">SequenceSubGraph</a></div><div class="ttdef"><b>Definition:</b> <a href="_sequence_sub_graph_8hpp_source.html#l00012">SequenceSubGraph.hpp:12</a></div></div>
<div class="ttc" id="class_untangler_html_ab78f66fdc696db46f18a0418c6749658"><div class="ttname"><a href="class_untangler.html#ab78f66fdc696db46f18a0418c6749658">Untangler::extend_HSPNPs_by_tagwalking</a></div><div class="ttdeci">uint64_t extend_HSPNPs_by_tagwalking()</div><div class="ttdoc">generates tag walk for each HSPNPs, finds common extensions and extends the bubbles ...</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l00280">Untangler.cc:280</a></div></div>
<div class="ttc" id="class_untangler_html_af5d8511828f1d9f6c494253df8c67c9b"><div class="ttname"><a href="class_untangler.html#af5d8511828f1d9f6c494253df8c67c9b">Untangler::get_all_tag_covered_paths</a></div><div class="ttdeci">std::vector&lt; SequenceGraphPath &gt; get_all_tag_covered_paths(sgNodeID_t from, sgNodeID_t to, std::set&lt; bsg10xTag &gt; &amp;tags, BufferedTagKmerizer &amp;btk)</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l01341">Untangler.cc:1341</a></div></div>
<div class="ttc" id="class_untangler_html_ae2506fd72b64a11eb91413ef29054a3d"><div class="ttname"><a href="class_untangler.html#ae2506fd72b64a11eb91413ef29054a3d">Untangler::solve_bubbly_paths</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; sgNodeID_t, sgNodeID_t &gt; &gt; solve_bubbly_paths()</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l00795">Untangler.cc:795</a></div></div>
<div class="ttc" id="class_untangler_html_a23b9f64ad4194c8740333ab7891c043c"><div class="ttname"><a href="class_untangler.html#a23b9f64ad4194c8740333ab7891c043c">Untangler::find_tag_neighbours_with_imbalance</a></div><div class="ttdeci">std::vector&lt; Link &gt; find_tag_neighbours_with_imbalance(uint32_t min_size, float min_ci, float max_ci, float end_perc=.1)</div><div class="ttdoc">grabs all &quot;long&quot; haplotype-specific nodes, uses tags to find neighbours, uses imbalance to impute dir...</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l00989">Untangler.cc:989</a></div></div>
<div class="ttc" id="class_untangler_html_afd3182e869342c4d435a46bb62b243cd"><div class="ttname"><a href="class_untangler.html#afd3182e869342c4d435a46bb62b243cd">Untangler::find_tag_neighbours</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; std::pair&lt; sgNodeID_t, uint32_t &gt; &gt; &gt; find_tag_neighbours(uint32_t min_size, float min_ci, float max_ci)</div><div class="ttdoc">grabs all &quot;long&quot; haplotype-specific nodes, uses tags to find neighbours. </div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l00920">Untangler.cc:920</a></div></div>
<div class="ttc" id="class_sequence_graph_html_a63599718b3a685c020739c2150bc3595"><div class="ttname"><a href="class_sequence_graph.html#a63599718b3a685c020739c2150bc3595">SequenceGraph::expand_node</a></div><div class="ttdeci">void expand_node(sgNodeID_t nodeID, std::vector&lt; std::vector&lt; sgNodeID_t &gt;&gt; bw, std::vector&lt; std::vector&lt; sgNodeID_t &gt;&gt; fw)</div><div class="ttdef"><b>Definition:</b> <a href="_sequence_graph_8cc_source.html#l00834">SequenceGraph.cc:834</a></div></div>
<div class="ttc" id="class_paired_read_linker_html_a882fb2b8454f2a6d63c65e9874126e45"><div class="ttname"><a href="class_paired_read_linker.html#a882fb2b8454f2a6d63c65e9874126e45">PairedReadLinker::remove_transitive_links</a></div><div class="ttdeci">void remove_transitive_links(int radius)</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l01694">Untangler.cc:1694</a></div></div>
<div class="ttc" id="class_paired_read_linker_html_a2d79e91c52a2fc7bc0d2de0a7748eb9e"><div class="ttname"><a href="class_paired_read_linker.html#a2d79e91c52a2fc7bc0d2de0a7748eb9e">PairedReadLinker::generate_links</a></div><div class="ttdeci">void generate_links(const std::vector&lt; bool &gt; &amp;to_link, int min_reads=5)</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l01572">Untangler.cc:1572</a></div></div>
<div class="ttc" id="class_untangler_html_a9d2be737b7d2e7842492785b9abb453a"><div class="ttname"><a href="class_untangler.html#a9d2be737b7d2e7842492785b9abb453a">Untangler::connect_neighbours_paths_to_same</a></div><div class="ttdeci">uint64_t connect_neighbours_paths_to_same(uint64_t min_size, float min_ci, float max_ci, int64_t max_distance, const std::vector&lt; std::vector&lt; std::pair&lt; sgNodeID_t, uint32_t &gt;&gt;&gt; &amp;tagneighbours, const std::vector&lt; std::vector&lt; std::pair&lt; sgNodeID_t, int64_t &gt;&gt;&gt; &amp;bndist, const std::vector&lt; std::vector&lt; std::pair&lt; sgNodeID_t, int64_t &gt;&gt;&gt; &amp;fndist)</div><div class="ttdef"><b>Definition:</b> <a href="_untangler_8cc_source.html#l01228">Untangler.cc:1228</a></div></div>
<div class="ttc" id="class_sequence_graph_html_a84b8d6ab28c22c20a468b1743796d4b0"><div class="ttname"><a href="class_sequence_graph.html#a84b8d6ab28c22c20a468b1743796d4b0">SequenceGraph::create_index</a></div><div class="ttdeci">void create_index()</div><div class="ttdef"><b>Definition:</b> <a href="_sequence_graph_8cc_source.html#l01110">SequenceGraph.cc:1110</a></div></div>
<div class="ttc" id="class_string_k_mer_factory_html"><div class="ttname"><a href="class_string_k_mer_factory.html">StringKMerFactory</a></div><div class="ttdef"><b>Definition:</b> <a href="_k_mer_factory_8h_source.html#l00058">KMerFactory.h:58</a></div></div>
<div class="ttc" id="class_link_html"><div class="ttname"><a href="class_link.html">Link</a></div><div class="ttdef"><b>Definition:</b> <a href="_generic_types_8hpp_source.html#l00040">GenericTypes.hpp:40</a></div></div>
<div class="ttc" id="struct_counter_html"><div class="ttname"><a href="struct_counter.html">Counter</a></div><div class="ttdef"><b>Definition:</b> <a href="_linkage_untangler_8cc_source.html#l00122">LinkageUntangler.cc:122</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b6cc841c9bdbd41507dc178df3332464.html">sglib</a></li><li class="navelem"><a class="el" href="dir_490085ae1b7a5eb44a4d1c80fc8d1b97.html">processors</a></li><li class="navelem"><b>Untangler.cc</b></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
