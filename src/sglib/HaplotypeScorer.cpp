//
// Created by Katie Barr (EI) on 14/11/2017.
//

#include "HaplotypeScorer.hpp"

HaplotypeScorer::HaplotypeScorer(SequenceGraph & sg): sg(sg), mapper(PairedReadMapper(sg)){

}

/**
 *
 *
 * @brief
 * sum each barcode's score for each haplotype
 * @return
 * Returns a vector containing: total records generated by the factory,
 * total records after filtering,
 * total file records present in the file and the total number of records after filtering.
 */

void HaplotypeScorer::decide_barcode_haplotype_support(){

    int support;
    int haplotypes_supported = 0;

    std::cout << "Calculating barcode haplotype" <<std::endl;
    for (auto &mapping:barcode_node_mappings) {
        if (mapping.second.size() > 1) {
            std::vector<sgNodeID_t> nodes;
            std::vector<int> scores;
            for (auto n: mapping.second) {
                nodes.push_back(n.first);
                scores.push_back(n.second);
            }
            if (*std::max_element(scores.begin(), scores.end()) > 1) {
                for (int i = 0; i < haplotype_ids.size(); i++) {
                    std::vector<sgNodeID_t> nodes_in_haplotype;
                    std::vector<sgNodeID_t> h;
                    h = haplotype_ids[i];
                    // find all nods in each haplotype that this barcode maps to
                    for (auto n1: nodes) {
                        if (std::find(h.begin(), h.end(), n1) != h.end()) {
                            nodes_in_haplotype.push_back(n1);
                        }
                    }
                    // somewhat arbitrary rule to decide if the barcode supports a haplotype enough
                    if (nodes_in_haplotype.size() >= (nodes.size() / 2) && nodes_in_haplotype.size() > 1) {
                        support = 0;
                        for (auto a: nodes_in_haplotype) {
                            support += mapping.second[a];
                        }
                        barcode_haplotype_mappings[mapping.first][i] = support;
                        haplotypes_supported += 1;
                    } else {
                        unused_barcodes.push_back(mapping.first);
                    }
                }
            }

        } else {
            unused_barcodes.push_back(mapping.first);
        }
        haplotypes_supported = 0;

    }


    std::cout << "Calculated haplotype support for each barcode, " << barcode_haplotype_mappings.size() <<  std::endl;

}

/**
 *
 *
 * @brief
 * Load haplotypes, at this point from text file with hap contig per line, haps separated by 'next' - generate this with old phaser code
 * * @return
 * populate array eith possible haplotpyes: this should be every comination of bubble contigs
 * \todo add functionality to find bubbles on graph, and generate possible haplotypes
 */
void  HaplotypeScorer::load_haplotypes(std::string haplotype_filename, int degree = 2){
    std::ifstream infile(haplotype_filename);
    std::string line;
    std::vector<std::string> fields;
    std::cout << "Loading haplotypes " << haplotype_filename << std::endl;
    std::string res;
    // no obvious way to access graph nodes directly, so store  names;
    std::vector<std::vector<sgNodeID_t> > haplotypes;
    while (std::getline(infile, line)) {
        std::istringstream(line) >> res;
        if (res == "next" ){
            std::vector<sgNodeID_t> next_haplotype;
            for (auto n:fields){
                sgNodeID_t node = sg.oldnames_to_ids[n];
                next_haplotype.push_back(node);
                haplotype_nodes.insert(node);
                node_id_haplotype_index_map[node].push_back(haplotypes.size());
                id_to_contig_name[node] = n;
                fields.clear();
            }

            haplotypes.push_back(next_haplotype);

            continue;
        } else {
            fields.push_back(res);

        }
        //TODO: sanity check, no ids should be 0, all haps should be same length


    }
    haplotype_ids =  haplotypes;

    std::cout << "Loaded " << haplotypes.size() << "haplotypes \n";
}


/**
 *
 *
 * @brief
 * Map reads to graph, sum up matches for each comntig mapped to by each barcode  barcode
 * @return
 * Load read files 1 and 2, populating map of id to barcode (this should be a vector the same as read to node but either my input reads are dodgy or there's something else wrong)
 * find mappings for each node in the bubble contigs. for each barcode, sum up the number of mappings for each node that a read with that barcode maps to
 *
 */
void HaplotypeScorer::count_barcode_votes(std::string r1_filename, std::string r2_filename){
    mapper.map_reads(r1_filename, r2_filename, prm10x);
    std::cout << "Mapped " << mapper.read_to_node.size() << " reads to " <<  mapper.reads_in_node.size() << "nodes" << std::endl;
    std::cout << "NOw counting barcode votes... " << std::endl;
    int counter = 0;
    for (auto &node:haplotype_nodes){
        //std::cout << "Node: " <<node <<std::endl;
        for (auto &mapping:mapper.reads_in_node[node>0?node:-node]){
            std::string barcode = mapper.read_ids_to_tags[mapping.read_id];
             barcode_node_mappings[barcode][node] += mapping.unique_matches;
            counter += 1;
        }
    }
    std::cout << "counted " << counter << " votes for " << barcode_node_mappings.size() << "barcodes";
};

/**
 *
 *
 * @brief
 * Decide winning phasing
 * @return
 * Calculate, for each haplotype, a number of metrics that represent how well the 10x reads support that phasing
 * loop over each barcode in turn, then each phasing pair
 * \todo decide criteria for winning haploype
 *
 */
int HaplotypeScorer::score_haplotypes() {
    auto number_haplotypes = haplotype_ids.size();

    std::cout << "Finding most supported of " << number_haplotypes<< " possible haplotypes"<<std::endl;
    //initialize score arrays- index is haplotype index
    std::vector<int > haplotype_support;
    std::vector<int > haplotype_not_support;
    std::vector<int> haplotype_overall_support;
    haplotype_support.resize(number_haplotypes);
    haplotype_not_support.resize(number_haplotypes);
    haplotype_overall_support.resize(number_haplotypes);
    std::map<std::pair<int, int>, int> hap_pair_not_support;
    std::map<std::pair<int, int>, int> hap_pair_support;
    std::map<std::pair<int, int>, int> hap_pair_support_total_score;
    std::string barcode;
    for (auto &bm: barcode_haplotype_mappings) {
        barcode = bm.first;
        std::vector<int> winners = winner_for_barcode(barcode); // ideally should be length 1
        for (auto winner:winners){
            int pair = haplotype_ids.size() - 1 - winner;
            haplotype_support[winner] += 1;

            hap_pair_support[std::make_pair(winner, pair)] += 1;
            haplotype_barcode_agree[winner][barcode] += bm.second[winner];
            haplotype_barcode_disagree[winner][barcode] += bm.second[pair];
        }
        for (int hap = 0; hap < number_haplotypes/ 2; hap++) {
            // pair = len(self.list_of_possible_haplotypes) -1 -haplotype
            auto pair = number_haplotypes - 1 - hap;
            if (bm.second.find(hap) != bm.second.end()) {
                haplotype_overall_support[hap] += bm.second[hap];
                hap_pair_support_total_score[std::make_pair(hap, pair)] += bm.second[hap];
            }

            if (bm.second.find(pair) != bm.second.end()) {
                haplotype_overall_support[pair] += bm.second[pair];
                hap_pair_support_total_score[std::make_pair(hap, pair)] += bm.second[pair];
            }
            if (bm.second.find(hap) == bm.second.end()) {
                haplotype_not_support[hap] += 1;
            }
            if (bm.second.find(pair) == bm.second.end()) {
                haplotype_not_support[pair] += 1;
            }
            if (bm.second.find(hap) == bm.second.end() and bm.second.find(pair) == bm.second.end()) {
                hap_pair_not_support[std::make_pair(hap, pair)] += 1;

            }
        }
    }
    // this gives value of max support, not index, must be better way

    auto winner_index = std::max_element(haplotype_support.begin(), haplotype_support.end());
    std::cout << "hap " << *winner_index << " winning contigs: " << std::endl;

    std::vector<int> support_winner;

    for (int h = 0; h < haplotype_ids.size(); h++) {
        if (haplotype_support[h] == *winner_index) {
            std::cout << "Winner: " << h << std::endl;
            support_winner.push_back(h);
        }
    }
   for (auto w: support_winner){
       for (auto h:haplotype_ids[w]){
           std::cout << id_to_contig_name[h] << " ";

       }
       std::cout << std::endl;

    }

    return 0;
}

/**
 *
 *
 * @brief
 * Find haplotype that a barcode votes for
 * * @return
 * loop over barcode aplotype mappings to find maximum support
 * if more than2 have same support both are returned
 * \todo decide heuristics to vote for winner
 */
std::vector<int>  HaplotypeScorer::winner_for_barcode(std::string barcode){
    int max=0;
    std::vector<int> winners;
    for (auto h:barcode_haplotype_mappings[barcode]){
        if (h.second > max){
            max = h.second;
        }
    }
    //TODO: DECIDE CRITERIA FOR MINIMUM SUPPORT
    for (auto h:barcode_haplotype_mappings[barcode]){
        if (h.second == max){
            winners.push_back(h.first);
        }
    }
    return winners;
}